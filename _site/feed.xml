<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-20T17:26:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jae’s Blog</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><entry><title type="html">완전탐색</title><link href="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/" rel="alternate" type="text/html" title="완전탐색" /><published>2024-02-17T20:00:00+09:00</published><updated>2024-02-20T17:06:51+09:00</updated><id>http://localhost:4000/cs/algorithm/exhaustive-search</id><content type="html" xml:base="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#완전탐색" id="markdown-toc-완전탐색">완전탐색</a></li>
</ul>

<h2 id="완전탐색">완전탐색</h2>

<p>완전탐색 알고리즘은 가능한 모든 경우의 수를 탐색하여 문제를 해결하는 방식이다.<br />
모든 가능성을 시도하면서 필요한 답을 찾아내는 방식으로 동작한다.</p>

<p>이는 간단하고 직관적이지만, 많은 경우에 있어 효율성이 낮은 편이다.</p>

<p>완전 탐색의 특징으로는 다음이 있다:</p>

<ul>
  <li>
    <p><b>모든 가능한 경우 고려:</b> 문제에 대한 모든 가능한 경우의 수를 검사한다.</p>
  </li>
  <li>
    <p><b>순서대로 나열:</b> 일반적으로 완전 탐색은 경우의 수를 나열하며 해를 찾는다.</p>
  </li>
  <li>
    <p><b>쉽게 이해 가능:</b> 구현이 간단하고 직관적이지만 효율성이 떨어진다.</p>
  </li>
</ul>

<p>선형 구조를 완전 탐색하는 순차 탐색 방식과 비선형 구조를 완전 탐색하는 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이<br />
완전 탐색에 사용되는 가장 기본적인 도구들이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="algorithm" /></entry><entry><title type="html">스택과 큐</title><link href="http://localhost:4000/cs/datastructure/2024-02-17-stack_queue/" rel="alternate" type="text/html" title="스택과 큐" /><published>2024-02-17T15:00:00+09:00</published><updated>2024-02-17T22:44:16+09:00</updated><id>http://localhost:4000/cs/datastructure/stack_queue</id><content type="html" xml:base="http://localhost:4000/cs/datastructure/2024-02-17-stack_queue/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#스택" id="markdown-toc-스택">스택</a>    <ul>
      <li><a href="#overflowunderflow" id="markdown-toc-overflowunderflow">Overflow/Underflow</a></li>
    </ul>
  </li>
  <li><a href="#큐" id="markdown-toc-큐">큐</a></li>
</ul>

<p>컴퓨터에서 자주 사용되는 스택과 큐라는 자료구조에 대해서 알아보자.</p>

<h2 id="스택">스택</h2>
<p><br />
스택은 데이터의 삽입과 삭제가 한 쪽에서만 이루어지는 선형 자료구조이다. <br />
이러한 삽입과 삭제 구조로 인해 스택에서의 데이터 삭제는 삽입된 순서의 역순으로 삭제되는 특징을 가지며,<br />
이를 <b>선입후출</b> 또는 <b>후입선출</b>, 영어로 <b>Last In First Out</b>, 줄여서 <b>LIFO</b>라고 한다.<br />
스택에서는 삽입과 삭제라는 용어보다는 Push와 Pop이라는 용어를 사용한다.</p>

<p class="figcaption"><img src="/assets/img/postimg/cs/datastructure/stack_queue/stack_1.png" alt="pushpop" />      <br />
스택의 푸시/팝 연산 <i>출처: https://www.programiz.com/dsa/stack</i></p>

<p>일반적으로 가장 위 데이터가 쌓여있는 위치를 Top이라고 부른다.</p>

<h3 id="overflowunderflow">Overflow/Underflow</h3>
<p><br />
오버플로우는 스택에 삽입 연산을 수행할 때 발생하는 문제이며, 이는 스택을 위해 할당된 저장 공간이 초과되어 더 이상 데이터를 삽입할 수 없는 상황을 말한다.</p>

<p>반대로, 언더플로우는 삭제 연산을 수행할 때 발생하며, 스택에 데이터가 없는 상태에서 삭제를 시도할 때 일어나는 문제이다.</p>

<h2 id="큐">큐</h2>
<p><br />
큐는 데이터의 삽입과 삭제가 서로 다른 쪽에서 이루어지는 선형 자료구조이다. 
그럼으로, 스택과는 달리 삽입된 순서로 데이터가 삭제되며 이는 <b>선입선출</b> 형식이며, 영어로 <b>First In First Out</b> 줄여서 <b>FIFO</b>라고 한다.</p>

<p>큐의 앞부분을 Front, 뒷부분을 Rear라고 한다.<br />
큐의 Front와 Rear는 모두 처음에 -1에서 시작한다(F = R = -1).<br />
데이터가 삽입이 될 수록 Rear는 한 칸씩 뒤로 이동하며, 데이터가 삭제될 시 Front가 뒤로 한 칸씩 움직인다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="datastructure" /></entry><entry><title type="html">Ethernet</title><link href="http://localhost:4000/2024-02-15-ethernet/" rel="alternate" type="text/html" title="Ethernet" /><published>2024-02-15T00:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/ethernet</id><content type="html" xml:base="http://localhost:4000/2024-02-15-ethernet/"><![CDATA[]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Exceptional Control Flow</title><link href="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/" rel="alternate" type="text/html" title="Exceptional Control Flow" /><published>2024-02-08T19:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science,/os/exceptional_control_flow</id><content type="html" xml:base="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ecf" id="markdown-toc-ecf">ECF</a></li>
  <li><a href="#예외상황" id="markdown-toc-예외상황">예외상황</a>    <ul>
      <li><a href="#인터럽트-1" id="markdown-toc-인터럽트-1">인터럽트</a></li>
      <li><a href="#트랩-1" id="markdown-toc-트랩-1">트랩</a></li>
      <li><a href="#오류-1" id="markdown-toc-오류-1">오류</a></li>
      <li><a href="#중단-1" id="markdown-toc-중단-1">중단</a></li>
    </ul>
  </li>
  <li><a href="#시스템-콜" id="markdown-toc-시스템-콜">시스템 콜</a></li>
</ul>

<h2 id="ecf">ECF</h2>

<p>예외적인 제어흐름 (exceptional control flow, ECF)은 운영체제가 입출력, 프로세스, 가상메모리 등을 구연하기 위해 사용하는 기본 메커니즘이다.<br />
ECF를 이해하면 응용 프로그램들이 어떻게 운영체제와 상호작용 하는지 이해하는데에 도움이 된다. 
응용 프로그램은 트랩 또는 시스템 콜이라고 알려진 ECF의 한 가지 형태를 사용해서 운영체제로부터 서비스를 요청한다.</p>

<h2 id="예외상황">예외상황</h2>

<p>예외상황은 예외적인 제어흐름의 한가지 형태이며, 하드웨어와 운영체제에 의해 구현된다.<br />
프로세서 상태의 변화에 대한 대응으로, ECF의 갑작스런 변화이다.</p>

<p>상태 변화는 이벤트라고 하는데 이 이벤트는 현재 인스트럭션의 실행에 직접적으로 관련될 수도 있다.
예로, 산술 오버플로우가 발생했다거나, 어떠한 인스트럭션이 divide by zero를 시도하는 것이 이러한 경우에 해당된다.<br />
또는, 현재 인스트럭션의 실행과 관련이 없을 수도 있는데, 예시로는 시스템 타이머가 정지하는 경우가 있겠다.</p>

<p>어떤 경우에서든 이러한 이벤트가 발생을 했다면, 그리고 프로세서가 이를 감지한다면,<br />
예외 테이블이라고 하는 점프 테이블을 통해 예외처리 핸들러라는 운영체제 서브루틴으로 간접 프로시저 콜을 한다. 
예외처리 핸들러는 발생한 이벤트의 종류에 따라 구분되며, 특정 종류의 이벤트를 처리하기 위해 설계된 서브루틴이다.</p>

<p>예외처리 핸들러가 처리를 한 후에는 이벤트의 종류에 따라 핸들러는 다음 세 가지 중 하나를 한다:</p>

<ol>
  <li>
    <p>제어를 현재의 인스트럭션으로 돌려준다.<br />
여기서 현재의 인스트럭션이라 함은, 이벤트 발생 시점에 실행되고 있던 인스트럭션을 지칭한다.</p>
  </li>
  <li>
    <p>제어를 다음 인스트럭션으로 돌려준다. 
여기서 다음 인스트럭션은 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션이다.</p>
  </li>
  <li>
    <p>중단된 프로그램을 종료한다.</p>
  </li>
</ol>

<p>예외상황은 네 가지의 종류로 구분된다:</p>

<h3 id="인터럽트-1">인터럽트</h3>

<h3 id="트랩-1">트랩</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>트랩은 어떤 인스트럭션을 실행한 결과로 발생하는 의도적인 예외상황이다. 
트랩 핸들러는 제어를 다음 인스트럭션으로 돌려준다. 
트랩의 가장 종요한 사용은 시스템 콜이라는 인터페이스를 제공하는 것이다. 
</code></pre></div></div>

<h3 id="오류-1">오류</h3>

<h3 id="중단-1">중단</h3>

<h2 id="시스템-콜">시스템 콜</h2>

<p>시스템 콜, 또는 시스템 호출은 응용 프로그램이 운영체제의 커널에 서비스를 요청하기 위한 메커니즘이다.<br />
여기서 서비스라 함은, 다음을 포함한다:</p>

<ul>
  <li>파일 작업 수행</li>
  <li>프로세스 생성 및 관리</li>
  <li>메모리 관리</li>
  <li>입출력 연산 처리</li>
</ul>

<p>프로그램이 운영 체제와의 상호작용을 필요로 하는 작업을 수행해야 할 경우, 프로그램은 시스템 콜을 한다.<br />
이렇게 함으로 프로그램은 코드를 커널 모드에서 실행할 수 있게 되며 시스템 자원에 직접 접근할 수 있게 된다.
시스템 콜 인터페이스는 사용자 수준 프로그램이 커널과 통신할 수 있는 표준화된 방식을 제공한다.</p>

<p>프로그래머의 관점에서 시스템 콜은 보통의 함수 호출과 동일하다 (실제 구현은 매우 다르다). 
다만, 보통의 함수와 달리 시스템 콜은 사용자 모드가 아닌 커널 모드에서 돌아가며,<br />
이로 인해 커널 내에서 정의된 스택에 접근함으로 더욱 많은 권한을 가진 인스트럭션을 실행할 수 있게 된다.</p>

<p>x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해 제공된다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science," /><category term="OS" /><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" /><media:content medium="image" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Explicit &amp;amp; Implicit Free List</title><link href="http://localhost:4000/computer_science/2024-02-07-free_list/" rel="alternate" type="text/html" title="Explicit &amp;amp; Implicit Free List" /><published>2024-02-07T21:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/free_list</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-free_list/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#가용-리스트" id="markdown-toc-가용-리스트">가용 리스트</a>    <ul>
      <li><a href="#명시적-가용-리스트-1" id="markdown-toc-명시적-가용-리스트-1">명시적 가용 리스트</a></li>
      <li><a href="#묵시적-가용-리스트-1" id="markdown-toc-묵시적-가용-리스트-1">묵시적 가용 리스트</a></li>
      <li><a href="#차이-1" id="markdown-toc-차이-1">차이</a></li>
    </ul>
  </li>
</ul>

<h2 id="가용-리스트">가용 리스트</h2>

<p>가용 리스트는 메모리 할당 및 해제를 관리하기 위한 자료구조이며,<br />
동적으로 할당될 수 있는 메모리 블록을 추적하는 데 사용된다.<br />
즉, 전에 할당되었지만 반환되어 가용 가능한 메모리 블록에 대한 정보를 저장한다.<br />
가용 리스트는 일반적으로 운영 체제의 메모리 관리자 또는 프로그래밍 언어의 런타임 시스템에서 사용된다.</p>

<h3 id="명시적-가용-리스트-1">명시적 가용 리스트</h3>

<p>명시적 가용 리스트에서의 반환된 모든 메모리 블럭은 포인터 또는 참조 등의 추가적인 정보를 가지고 있으며, 
이는 다음 가용 가능한 메모리 블록을 명시적으로 나타낸다. <br />
명시적 가용 리스트는 연결 리스트 또는 다른 자료구조를 유지하며, 해당 자료구조의 각 노드에게 반환된 메모리 블록을 나타내게 함으로 
다음의 가용 가능 메모리 블록을 가르키게 한다.<br />
메모리 블록이 반환되는 시점에 할당기는 적절한 포인터 또는 참조를 갱신하여 해당 블록을 명시적 가용 리스트에 추가한다.<br />
메모리를 할당하기 위해 할당기는 명시적 가용 리스트를 탐색하여 충분한 크기의 메모리 블록을 찾고,
해당 메모리 블록을 가용 리스트에서 제거한 후 메모리를 요청한 프로세스에 할당한다.</p>

<h3 id="묵시적-가용-리스트-1">묵시적 가용 리스트</h3>

<p>묵시적 가용 리스트에서는 할당기가 할당 및 반환된 메모리 블록을 명시적인 포인터 또는 참조 없이 관리한다. <br />
반환된 메모리 블록은 직접적인 포인터나 참조 대신 힙 내에서의 각각의 크기와 위치로 구분된다.<br />
메모리 블록이 반환되는 시점에 할당기는 이를 가용 가능한 것으로 표시하며 인접한 반환된 블록들과 합쳐 더 큰 가용 가능한 블록을 만든다. 
메모리를 할당하기 위해 할당기는 해당 태스크에 사용되기 적절한 메모리 블록을 찾기 위해 크기와 위치를 고려하여 힙을 탐색 및 찾은 후 메모리를 할당한다.</p>

<h3 id="차이-1">차이</h3>

<p>명시적 가용 리스트와 묵시적 가용 리스트의 주요 차이는 가용 가능한 메모리 블록들의 정보를 관리하는 방식에 있다. <br />
명시적 가용 리스트는 직접적인 포인터 또는 참조를 사용하여 반환된 메모리 블록을 연결하여 관리하며,
추가적인 포인터 또는 참조를 저장해야 하기 때문에 일반적으로 더 많은 메모리를 필요로 한다.  <br />
이에 반해, 묵시적 가용 리스트는 힙 내에서의 메모리 블록의 위치와 크기에 의존하여 메모리의 가용 가능성을 판단하며, <br />
메모리 할당 시 적절한 메모리 블록을 찾기 위해 더 많은 시간(계산)이 필요하다 (힙이 파편화되어 있으면 더욱 그렇다).</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">동적 메모리 할당기</title><link href="http://localhost:4000/computer_science/2024-02-07-allocator/" rel="alternate" type="text/html" title="동적 메모리 할당기" /><published>2024-02-07T20:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/allocator</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-allocator/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동적-메모리-할당기" id="markdown-toc-동적-메모리-할당기">동적 메모리 할당기</a>    <ul>
      <li><a href="#명시적-할당기-1" id="markdown-toc-명시적-할당기-1">명시적 할당기</a></li>
      <li><a href="#묵시적-할당기-1" id="markdown-toc-묵시적-할당기-1">묵시적 할당기</a></li>
    </ul>
  </li>
</ul>

<h2 id="동적-메모리-할당기">동적 메모리 할당기</h2>

<p>저수준의 mmap과 munmap 함수들을 사용하여 가상메모리의 영역을 생성하고 삭제할 수 있지만, <br />
대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때 <i>동적 메모리 할당기</i>라는 것을 사용하는 것이 편리하고 호환성이 좋다고 여겨진다.</p>

<p>동적 메모리 할당기는 <i>heap</i>, 즉 프로세스의 가상 메모리 영역을 관리한다. <br />
할당기는 힙을 다양한 크기의 블록들의 집합으로 관리하며, 이 때 각 블록은 할당되었거나 가용한 가상메모리의 연속적인 묶음이다.</p>

<p>할당기에는 두 개의 기본 유형이 있다:</p>
<ul>
  <li>명시적 할당기</li>
  <li>묵시적 할당기</li>
</ul>

<p>두 유형 모두 할당시에는 명시적으로 블록을 할당하도록 요구하지만, 할당된 블록을 반환하는 방식에 차이가 있다.</p>

<h3 id="명시적-할당기-1">명시적 할당기</h3>

<p>명시적 할당기는 할당된 블록의 반환하기 위해 애플리케이션이 명시적으로 요구해야 한다. <br />
예시로는 C 표준 라이브러리의 <code class="language-plaintext highlighter-rouge">malloc()</code> 함수가 있다.<br />
C 프로그램은 malloc 함수를 호출해서 블록을 할당하며, 할당된 블록을 반환하기 위해서는 <code class="language-plaintext highlighter-rouge">free()</code>함수를 호출해야 한다. <br />
C++ 에서는 <code class="language-plaintext highlighter-rouge">new()</code>와 <code class="language-plaintext highlighter-rouge">delete()</code>가 있다.</p>

<h3 id="묵시적-할당기-1">묵시적 할당기</h3>

<p>묵시적 할당기는 할당된 블록이 더 이상 프로그램에 의해 사용되지 않는지 할당기가 검출할 수 있을 것을 요구하며, <br />
이러한 검출을 통해 블록의 반환이 별도의 함수 호출 없이 이루어진다.<br />
묵시적 할당기는 <i>garbage collector</i>라고도 알려져 있으며, 자동으로 사용하지 않는 할당된 블록을 반환하는 작업을 가비지 컬렉션이라고 부른다. <br />
List, ML, Java같은 고급 언어는 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용한다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">MMAP &amp;amp; MUNMAP</title><link href="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/" rel="alternate" type="text/html" title="MMAP &amp;amp; MUNMAP" /><published>2024-02-07T15:43:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/mmap_munmap</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#mmap" id="markdown-toc-mmap">MMAP</a>    <ul>
      <li><a href="#address-1" id="markdown-toc-address-1">address</a></li>
      <li><a href="#length-1" id="markdown-toc-length-1">length</a></li>
      <li><a href="#protect-1" id="markdown-toc-protect-1">protect</a></li>
      <li><a href="#flags-1" id="markdown-toc-flags-1">flags</a></li>
      <li><a href="#filedes" id="markdown-toc-filedes">filedes</a></li>
      <li><a href="#offset-1" id="markdown-toc-offset-1">offset</a></li>
    </ul>
  </li>
  <li><a href="#munmap" id="markdown-toc-munmap">MUNMAP</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수와 <code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상 메모리의 영역들을 생성하고 삭제할 수 있게 해주는 함수들이다.</p>

<h2 id="mmap">MMAP</h2>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수는 Memory Map이라는 뜻을 가지며, 말 그대로 메모리를 매핑하여 가상 메모리의 영역을 생성하고 삭제할 수 있게 해준다.
커널에 새 가상메모리 영역을 생성해 줄 것을 요청하며, 객체들을 이 영역으로 매핑할 수 있다.</p>

<p>이를 사용해 성공적으로 파일을 메모리에 매핑한다면, 해당 메모리의 주소값이 반환된다.<br />
<code class="language-plaintext highlighter-rouge">mmap()</code>함수는 다음의 6 인자들을 받는다.  <br />
<code class="language-plaintext highlighter-rouge">void *address</code>, <code class="language-plaintext highlighter-rouge">size_t length</code>, <code class="language-plaintext highlighter-rouge">int protect</code>, <code class="language-plaintext highlighter-rouge">int flags</code>, <code class="language-plaintext highlighter-rouge">int filedes</code>, <code class="language-plaintext highlighter-rouge">off_t offset</code></p>

<h3 id="address-1">address</h3>

<p>이 인자는 매핑에 선호하는 시작 주소를 함수로 전달하며, 대개 <code class="language-plaintext highlighter-rouge">NULL</code>로 명시한다.<br />
다른 매핑이 해당 주소에 존재하지 않다면 커널은 근처의 페이지 영역을 선택하여 매핑을 한다.
해당 인자에 <code class="language-plaintext highlighter-rouge">NULL</code>이 패스된다면 커널은 적절한 위치를 찾아 매핑을 한다.</p>

<h3 id="length-1">length</h3>

<p>매핑 될 바이트의 수이다.</p>

<h3 id="protect-1">protect</h3>

<p>이 인자는 어떤 접근이 허용되는지 제어하기 위해 사용된다.<br />
파일에 대응되는 메모리 영역의 보호 특성을 결정하기 위해 다음의 비트들이 있으며,
해당 비트들의 논리 OR 형태로도 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">PROT_EXEC</code> : 실행 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_READ</code> : 읽기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_WRITE</code> : 쓰기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_NONE</code> : 접근 불가능한 페이지</p>

<h3 id="flags-1">flags</h3>

<p>매핑의 유형과 동작 구성 요소를 결정하는 값이다.
이는 대응되는 페이지 복사본에 대한 수정이 해당 프로세스에서만 보일 것인지, 아니면 다른 참조하는 프로세스와 공유할 것인지를 설정한다.</p>

<p><code class="language-plaintext highlighter-rouge">MAP_SHARED</code> : 이 플래그는 매핑을 다른 모든 프로세스들과 공유하기 위해 사용된다. 매핑된 영역에 대한 수정은 파일에 다시 쓰여진다.<br />
<code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code> : 해당 플래그가 사용되면 매핑은 다른 프로세스들에게 보이지 않으며, 변경점들 또한 파일에 쓰여지지 않는다.<br />
<code class="language-plaintext highlighter-rouge">MAP_ANONYMOUS || MAP_ANON</code> : 익명의 매핑을 만들며, 파일 디스크립터로 인식하지 않는다. 어떠한 파일에도 연결되지 않으며, 힙을 늘리는 방식으로 사용된다.<br />
<code class="language-plaintext highlighter-rouge">MAP_FIXED</code> : 지정된 주소 이외의 다른 주소를 선택하지 않는다. 이 때, 지정된 주소가 사용될 수 없다면 mmap()은 실패한다.</p>

<h3 id="filedes">filedes</h3>

<p>매핑될 파일 디스크립터이다.</p>

<h3 id="offset-1">offset</h3>

<p>매핑할 때, 옮길 데이터의 시작점을 지정하는 인수이다.</p>

<h2 id="munmap">MUNMAP</h2>

<p><code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상메모리의 영역들을 삭제한다.</p>

<p>인수로는 <code class="language-plaintext highlighter-rouge">void *start</code>와 <code class="language-plaintext highlighter-rouge">size_t length</code>를 받으며,
이는 가상주소 <code class="language-plaintext highlighter-rouge">start</code>부터 <code class="language-plaintext highlighter-rouge">length</code>바이트로 이루어진 영역을 삭제하라는 말이다.<br />
<b>이후, 삭제된 영역으로의 참조는 세그먼트 오류를 발생시킨다.</b></p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">가상화</title><link href="http://localhost:4000/computer/science/2024-02-03-first-post/" rel="alternate" type="text/html" title="가상화" /><published>2024-02-03T13:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer/science/first-post</id><content type="html" xml:base="http://localhost:4000/computer/science/2024-02-03-first-post/"><![CDATA[<p>가상화란 컴퓨터 리소스의 추상화를 의미한다.</p>

<p>추상화라는 단어가 CS에는 매우 자주 등장하는 듯 한데, 개인적으로 무언가를 추상화 하려면 이미지가 중요하다고 생각해서 이미지를 찾아보니 이런 걸 찾았다:</p>

<p><img />&lt;/img&gt;</p>

<p>가상화란,
하나의 물리 리소스를 여러개의 논리 리소스처럼 기능 시키거나,<br />
여러 개의 물리 리소스를 하나의 논리 리소스처럼 기능케 한다.</p>

<p>이게 무슨 말이냐면,<br />
하나의 실물 컴퓨팅 자원을 마치 여러 개인 것처럼 가상으로 쪼개서 사용하거나,<br />
여러 개의 실물 컴퓨팅 자원들을 묶어서 하나의 자원인 것처럼 사용하겠다는 것이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer" /><category term="Science" /><summary type="html"><![CDATA[가상화란 컴퓨터 리소스의 추상화를 의미한다.]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2024-01-31-welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2024-01-31T22:35:04+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/jekyll/update/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024-01-31-welcome-to-jekyll/"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">힙 정렬</title><link href="http://localhost:4000/cs/algorithm/2024-01-15-heapsort/" rel="alternate" type="text/html" title="힙 정렬" /><published>2024-01-15T20:00:00+09:00</published><updated>2024-02-20T17:26:29+09:00</updated><id>http://localhost:4000/cs/algorithm/heapsort</id><content type="html" xml:base="http://localhost:4000/cs/algorithm/2024-01-15-heapsort/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#힙" id="markdown-toc-힙">힙</a></li>
  <li><a href="#힙-정렬" id="markdown-toc-힙-정렬">힙 정렬</a></li>
</ul>

<h2 id="힙">힙</h2>

<p>힙이란 완전 이진 트리의 일종이며, <br />
여러 개의 값들 중에서 최대값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.<br />
최대 힙 기준으로 큰 키값이 상위 레벨에 있고 작은 키값이 하위 레벨에 있으며<br />
이러한 특징으로 인해 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 이진 트리이다.</p>

<p>자세한 내용은 <a href="http://jaenam615.github.io/cs/datastructure/2024-01-12-heap/">힙</a>에 정리되어있다.</p>

<h2 id="힙-정렬">힙 정렬</h2>

<p>힙 자료구조를 사용하여 정렬하는 알고리즘이다.</p>

<p>이는 배열로 표현된 트리를 다시 배열로 정렬하는 방식으로 구현하는데,<br />
힙 배열의 루트에서 원소를 삭제하여 줄어든 힙 배열 크기 뒤에 남는 공간에 삭제한 원소를 도로 넣음으로 정렬을 한다.<br />
<br />
<img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F2133cb71-0c2c-48db-a62c-da90ddfc6ff9%2FUntitled.png?table=block&amp;id=3de1282c-d289-4b0b-8620-eb0006f54d8c&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=2000&amp;userId=&amp;cache=v2" alt="initialheap" width="500" /></p>

<table>
  <tbody>
    <tr>
      <td>50</td>
      <td>30</td>
      <td>20</td>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td>16</td>
    </tr>
  </tbody>
</table>

<p>위는 값들이 들어간 힙과 해당 힙이 배열로 표현된 것이다.</p>

<p>힙 정렬을 하려면 값들을 삭제해야 하는데, 힙에서의 삭제는 루트 노드에서만 이루어진다.<br />
주의해야 할 점은, <b>삭제되는 값 자체는 루트 노드의 값이지만, 삭제되는 노드는 단말 노드라는 점이다.</b><br />
삭제되는 노드는 단말 노드, 그 중 가장 오른쪽의 노드여야 하는데<br />
이것은 항상 완전 이진 트리를 유지해야 하기 때문이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="algorithm" /><category term="알고리즘" /><category term="정렬" /></entry></feed>