<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-27T10:29:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jae’s Blog</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><entry><title type="html">프록시</title><link href="http://localhost:4000/cs/network/2024-02-23-proxy/" rel="alternate" type="text/html" title="프록시" /><published>2024-02-23T20:30:00+09:00</published><updated>2024-02-27T10:01:59+09:00</updated><id>http://localhost:4000/cs/network/proxy</id><content type="html" xml:base="http://localhost:4000/cs/network/2024-02-23-proxy/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#프록시" id="markdown-toc-프록시">프록시</a>    <ul>
      <li><a href="#프록시란" id="markdown-toc-프록시란">프록시란?</a></li>
      <li><a href="#프록시를-쓰는-이유" id="markdown-toc-프록시를-쓰는-이유">프록시를 쓰는 이유</a></li>
    </ul>
  </li>
  <li><a href="#프록시-서버의-종류" id="markdown-toc-프록시-서버의-종류">프록시 서버의 종류</a>    <ul>
      <li><a href="#포워드-프록시" id="markdown-toc-포워드-프록시">포워드 프록시</a></li>
      <li><a href="#리버스-프록시" id="markdown-toc-리버스-프록시">리버스 프록시</a></li>
    </ul>
  </li>
</ul>

<h2 id="프록시">프록시</h2>

<h3 id="프록시란">프록시란?</h3>

<p>인터넷 접속을 할 때, <strong>빠른 액세스</strong>나 <strong>안전한 통신</strong>등을 확보하기 위해 사용되는 중계 서버를 프록시 서버라고 한다.<br />
프록시를 사용하지 않고 서버에 요청을 보내면 다음과 같이 서버에 IP 주소가 노출된다.</p>

<p class="figcaption"><img src="https://assets-global.website-files.com/5efc3ccdb72aaa7480ec8179/61563358dcbea98e1a4b7d92_web-browsing-without-proxy.png" alt="noproxy" />
<i>출처:Upguard</i></p>

<p>프록시 서버는 클라이언트와 서버 사이에 위치하며, 클라이언트의 요청을 대신 받아 서버에 전달하고, 서버의 응답을 대신 받아 클라이언트에 전달한다.</p>

<p class="figcaption"><img src="https://assets-global.website-files.com/5efc3ccdb72aaa7480ec8179/615635613cd4216f4d4f01d5_web-browsing-with-proxy.png" alt="proxy" />
<i>출처:Upguard</i></p>

<h3 id="프록시를-쓰는-이유">프록시를 쓰는 이유</h3>

<p>프록시를 사용하는 이유는 여러가지가 있지만, 그 중 주요한 요소는 다음과 같다.</p>

<ol>
  <li>보안
    <ul>
      <li>프록시 서버를 통해 요청을 전달하면 서버에는 프록시의 IP가 노출됨으로, 클라이언트의 실제 IP 주소를 숨길 수 있다.</li>
      <li>프록시 서버는 클라이언트의 요청을 검사하여 악성코드나 해킹 시도를 차단할 수 있다.</li>
      <li>바이러스 등에 대한 보안 대책을 프록시 서버에 구현함으로써, 클라이언트와 서버 모두 보안을 강화할 수 있다.</li>
    </ul>
  </li>
  <li>속도향상 (with cache)
    <ul>
      <li>프록시 서버는 웹페이지를 가져올 때 자신의 DB(캐시)에 저장하여, 같은 요청이 들어왔을 때 서버에 요청을 보내지 않고 캐시된 데이터를 전달함으로써 속도를 향상시킬 수 있다.</li>
      <li>특히, 이미지나 동영상 등의 큰 파일을 다운로드 할 때, 프록시 서버를 통해 다운로드 받으면 더 빠르게 다운로드 받을 수 있다.</li>
      <li>프록시 서버는 클라이언트의 요청을 압축하여 전달함으로써 속도를 향상시킬 수 있다.</li>
    </ul>
  </li>
  <li>로그 기록 및 관리
    <ul>
      <li>프록시 서버는 클라이언트의 요청과 서버의 응답을 기록함으로써, 트래픽을 모니터링하고 관리할 수 있다.</li>
      <li>프록시 서버는 특정 사이트에 대한 접근을 제한할 수 있으며, 이는 보통 회사나 학교 등에서 특정 사이트에 대한 접근을 제한하기 위해 사용된다.</li>
    </ul>
  </li>
</ol>

<h2 id="프록시-서버의-종류">프록시 서버의 종류</h2>

<p>프록시 서버는 크게 포워드 프록시와 리버스 프록시로 나뉘며, 서로 다른 역할을 한다.<br />
더 세부적으로 들어가면 익명 프록시, 투명 프록시 등으로 나뉘지만,<br />
본문에서는 포워드 프록시와 리버스 프록시에 대해서만 간결하게 다룬다.</p>

<h3 id="포워드-프록시">포워드 프록시</h3>

<p>일반적으로 말하는 프록시 서버는 포워드 프록시를 의미한다.
클라이언트와 외부 서버 사이의 트래픽을 중계하는 서버이며, 이는 사전 설정된 규칙에 따라 트래픽을 제어할 수 있다.</p>

<p>클라이언트와 서버 사이에서 요청을 중계하며 요청과 응답은 프록시 서버를 거쳐서 전달된다.</p>

<p>포워드 프록시는 클라이언트를 감추는 역할을 한다.</p>

<h3 id="리버스-프록시">리버스 프록시</h3>

<p>리버스 프록시란 클라이언트에게는 일반적인 서버로 인식되는 프록시 서버이다.
포워드 프록시의 경우와는 다르게 리버스 프록시는 보통 내부 네트워크에서 사용되며 클라이언트의 요청을 받아 내부 서버로 전달한다.<br />
이렇게 구축을 하면 클라이언트는 내부 서버의 존재를 알 수 없으며, 내부 서버의 IP 주소를 숨길 수 있고<br />
내부 서버들로의 접근은 리버스 프록시를 통해서만 가능하다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="network" /></entry><entry><title type="html">[백준] 18870 좌표 압축</title><link href="http://localhost:4000/coding/baekjoon/2024-02-23-boj18870/" rel="alternate" type="text/html" title="[백준] 18870 좌표 압축" /><published>2024-02-23T13:00:00+09:00</published><updated>2024-02-26T23:17:11+09:00</updated><id>http://localhost:4000/coding/baekjoon/boj18870</id><content type="html" xml:base="http://localhost:4000/coding/baekjoon/2024-02-23-boj18870/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#문제-설명" id="markdown-toc-문제-설명">문제 설명</a></li>
  <li><a href="#문제-풀이" id="markdown-toc-문제-풀이">문제 풀이</a></li>
  <li><a href="#최종-코드" id="markdown-toc-최종-코드">최종 코드</a></li>
</ul>

<h2 id="문제-설명">문제 설명</h2>

<p><b><a href="https://www.acmicpc.net/problem/18870">문제 링크</a></b></p>

<p><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F20346cbd-de27-4b06-a942-8ffc9e790ff3%2FUntitled.png?table=block&amp;id=906abbc2-50c4-4cd2-afee-7add4cff0954&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=2000&amp;userId=&amp;cache=v2" alt="18870" /></p>

<p>문제를 처음 확인해보면 설명이 다소 불친절하다고 느껴지지만, 아래의 예제 입출력을 보고 나면 무엇을 해야할지가 꽤 명확해진다.</p>

<p><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2Ff0f6f4c4-61e7-43cd-b083-e532ff5fbc07%2FUntitled.png?table=block&amp;id=4cfc2932-09b3-4c79-a17e-826c36037fdb&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=2000&amp;userId=&amp;cache=v2" alt="i/o" /></p>

<p>-10^9^ 부터 10^9^까지 있는 수직선 상에 있는 점들을 가장 작은 수부터 큰 수까지 0부터 N까지 나열하라는 문제다.<br />
여기서, 입력값에 같은 수가 나온다면 해당 수는 새로 나열되어도 같은 출력값을 공유하며, 이것만 해결하면 크게 어려운 문제는 아니다.</p>

<h2 id="문제-풀이">문제 풀이</h2>

<p>입력받은 값을 리스트에 넣어 set으로 만든 후 해당 값들을 오름차순 정리를 하여<br />
작은 값부터 키값을 0부터 주어 딕셔너리를 활용해 해결하는 방법이 정석적인 방법 같다.</p>

<p>다만 파이썬에는 enumerate라는 함수가 있으며, 해당 함수를 제대로 활용해볼 기회가 없었어서<br />
이를 활용해 문제를 해결해보기로 했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">Xn</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">enumerate</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())))</span>
</code></pre></div></div>

<p>예제를 기준으로, enumerate를 통해 입력받는 값들(2, 4, -10, 4, -9)에 각각 투플 형식으로 번호를 달아준다. 
이렇게 되면 리스트 Xn에 들어가는 원소는 <code class="language-plaintext highlighter-rouge">[(0,2), (1,4), (2,-10), (3,4), (4,-9)]</code>가 된다.</p>

<p><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2Fc6a42162-0a11-495d-9e0a-3de657fdec1d%2FUntitled.png?table=block&amp;id=73885a55-e17f-4e1d-bcf6-bc8f32e52adb&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=500&amp;userId=&amp;cache=v2&quot;" alt="output" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">final</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>sort함수를 사용해서 Xn 원소들의 두 번째 값을 기준으로 정렬하고,<br />
(Xn의 원소들은 (인덱스, 값)의 투플 형식으로 있기 때문에 x[1]을 기준으로 정렬해야 값의 크기 기준으로 정렬된다)<br />
정렬된 후 리스트 Xn의 원소는 다음과 같은 순서로 되어있다: <code class="language-plaintext highlighter-rouge">[(2,-10), (4,-9), (0,2), (1,4), (3,4)]</code></p>

<p>해당 좌표들에 새로운 좌표(0부터 시작하는 압축된 좌표)를 부여하기 위해 새 리스트를 하나 만들어주고,<br />
이 리스트의 Xn[0][0]번째 원소를 0으로 초기화해준다.<br />
Xn[0][0]은 가장 작은 원소가 입력된 순서이며, 이 때 입력된 값을 새로운 압축 좌표 내에서 0으로 초기 설정하는 작업이다.</p>

<p>이 때 리스트 <code class="language-plaintext highlighter-rouge">final</code>의 값은 <code class="language-plaintext highlighter-rouge">[-1,-1,0,-1,-1]</code>이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">curvalue</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">Xn</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>  
        <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">curvalue</span>
        <span class="n">curvalue</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
</code></pre></div></div>

<p>위의 부분은 Xn의 원소의 갯수만큼 압축 좌표 리스트 <code class="language-plaintext highlighter-rouge">final</code>에 값을 채우는 과정이다.<br />
Xn은 이미 실제 입력된 값 기준으로 정렬되어있기 때문에, 같은 수가 반복되어 나온다면 직전과 같은 값을 넣어줄 수 있다.</p>

<h2 id="최종-코드">최종 코드</h2>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">Xn</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">enumerate</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())))</span>
<span class="n">Xn</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">final</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">curvalue</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">len</span><span class="p">(</span><span class="n">Xn</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>  
        <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">curvalue</span>
        <span class="n">curvalue</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="n">Xn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        
<span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">final</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="coding" /><category term="baekjoon" /><summary type="html"><![CDATA[백준 2156 난이도: 실버 2 알고리즘: 정렬]]></summary></entry><entry><title type="html">Ethernet</title><link href="http://localhost:4000/cs/2024-02-21-ethernet/" rel="alternate" type="text/html" title="Ethernet" /><published>2024-02-21T10:43:00+09:00</published><updated>2024-02-21T15:34:26+09:00</updated><id>http://localhost:4000/cs/ethernet</id><content type="html" xml:base="http://localhost:4000/cs/2024-02-21-ethernet/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#개요" id="markdown-toc-개요">개요</a></li>
  <li><a href="#이더넷-물리-계층" id="markdown-toc-이더넷-물리-계층">이더넷 물리 계층</a></li>
</ul>

<h2 id="개요">개요</h2>

<p>1973년 Xerox의 로버트 메트칼프(Robert Metcalfe)와 데이비드 보그(David Boggs)가 개발한 로컬 네트워크(LAN) 기술로,<br />
이더넷은 근거리 통신망(LAN)을 유선으로 구현하는 기술 방식이며, 빠른 속도와 저렴한 비용 등의 장점으로 널리 사용되고 있다.</p>

<p>장치가 네트워크를 통해 데이터 패킷을 다른 장치들과 교환하며 통신할 수 있도록 하는 기술이다.</p>

<h2 id="이더넷-물리-계층">이더넷 물리 계층</h2>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /></entry><entry><title type="html">[백준] 2156 포도주 시식</title><link href="http://localhost:4000/coding/baekjoon/2024-02-20-boj2156/" rel="alternate" type="text/html" title="[백준] 2156 포도주 시식" /><published>2024-02-20T13:00:00+09:00</published><updated>2024-02-26T23:17:11+09:00</updated><id>http://localhost:4000/coding/baekjoon/boj2156</id><content type="html" xml:base="http://localhost:4000/coding/baekjoon/2024-02-20-boj2156/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#문제-설명" id="markdown-toc-문제-설명">문제 설명</a></li>
  <li><a href="#문제-풀이" id="markdown-toc-문제-풀이">문제 풀이</a></li>
  <li><a href="#최종-코드" id="markdown-toc-최종-코드">최종 코드</a></li>
</ul>

<h2 id="문제-설명">문제 설명</h2>

<p><b><a href="https://www.acmicpc.net/problem/2156">문제 링크</a></b></p>

<p><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F28f7a4c0-897a-444e-9589-f199eccdad58%2FUntitled.png?table=block&amp;id=1f1078f7-2b5e-491a-af1a-fe9eaf20a315&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=2000&amp;userId=&amp;cache=v2" alt="2156" /></p>

<p>문제를 살펴보면, 연속으로 놓은 포도주를 2번까지만 마실 수 있고, 연이은 두개를 마시는 경우에는 무조건 하나를 건너뛰어야 한다는 점을 알 수 있다.</p>

<h2 id="문제-풀이">문제 풀이</h2>

<p>동적 계획법을 사용하여 풀 수 있다. 
점화식만 잘 세우면 크게 어렵지 않은 문제이기 때문에 점화식을 잘 세우고 Bottom-Up 방식으로 cache를 채워서 최적해를 구하는 방식으로 진행하면 된다.</p>

<p>우선 입력받는 포도주의 값들을 배열로 정리해준다.<br />
이 때, 인덱스 관리를 쉽게 하기 위해 첫 인덱스(0)에는 0을 넣어주고 시작한다.</p>

<p>이후, 순차적으로 포도주가 있는 잔들을 지나간다고 생각하며,<br />
해당 포도주를 마셨을 때와 마시지 않았을 때를 생각해서 해당 시점에서의 최대값을 저장할 cache 배열을 생성한다.<br />
이 cache배열(코드에는 max_drinking)을 각 포도주들의 위치와 매핑시켜주기 위해 첫 인덱스의 값은 0으로 둔다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="c1"># 포도주의 가치를 저장할 배열
</span><span class="n">wine</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">wine</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">()))</span>

<span class="c1"># --- 위까지가 입력값 --- #
</span>
<span class="n">max_drinking</span><span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="c1">#초기값 설정
</span><span class="n">max_drinking</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nb">max</span> <span class="n">drinking</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">wine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>해당 문제에서 i번째 포도주에 왔을 때 고려할 수 있는 선택지는 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># i번째 포도주를 마시지 않아 그 전 값과 같을 때 
# (직전 두 잔을 모두 마시는 것이 i번째를 마시는것보다 이득인 경우)
</span><span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># i-1번째 포도주를 마시지 않고 i번째 포도주를 마시는 경우
</span><span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># i-1번째 포도주와 i번째 포도주를 마시는 경우 
# (이 때는 i-2번째 포도주를 건너뛰었다는 말이 된다)
</span><span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div></div>

<p>각 경우의 수를 시각적으로 표현해보자.<br />
O는 해당 포도주를 마신 것이고, X는 해당 포도주를 마시지 않은 것이다.</p>

<p>첫 번째 경우: 
|  i-3  |  i-2  |  i-1  |  i   |<br />
|   X   |   O   |   O   |  X   |</p>

<p>두 번째 경우: 
(이 부분이 살짝 까다로운데, max_drinking[i-1]의 시점에서 생각해보면,<br />
i-1번째 포도주를 안 마셨다는 것은 해당 시점에 위의 첫 번째 경우를 선택했다는 말이며, 이는 그 직전 두 잔을 마셨다는 말이다)<br />
|  i-3  |  i-2  |  i-1  |  i   |<br />
|   O   |   O   |   X   |  O   |</p>

<p>세 번째 경우:<br />
|  i-3  |  i-2  |  i-1  |  i   |<br />
|   O   |   X   |   O   |  O   |</p>

<p>이 중 최대값을 구하여 max_drinking dpcache에 넣어준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>  
        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
</code></pre></div></div>

<h2 id="최종-코드">최종 코드</h2>

<p>위의 개념들과 코드들을 잘 정리해서 작성하면 아래와 같은 최종 코드가 나온다.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>

<span class="n">wine</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># 포도주 양을 저장할 리스트
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">wine</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">()))</span>

<span class="c1"># 각 포도주 양을 마실 때의 최대 양을 저장할 리스트
</span><span class="n">max_drinking</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

<span class="c1"># 초기값 설정
</span><span class="n">max_drinking</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">max_drinking</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">wine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># 동적 프로그래밍을 통한 최대 양 계산
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># i번째 잔을 마시지 않는 경우
</span>        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>  <span class="c1"># i번째 잔을 마시는 경우
</span>        <span class="n">max_drinking</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">wine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># i-1번째와 i번째 잔을 연속해서 마시는 경우
</span>    <span class="p">)</span>

<span class="c1"># 결과 출력
</span><span class="nf">print</span><span class="p">(</span><span class="n">max_drinking</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
</code></pre></div></div>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="coding" /><category term="baekjoon" /><summary type="html"><![CDATA[백준 2156 난이도: 실버 1 알고리즘: 동적계획법]]></summary></entry><entry><title type="html">완전탐색</title><link href="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/" rel="alternate" type="text/html" title="완전탐색" /><published>2024-02-17T20:00:00+09:00</published><updated>2024-02-20T17:06:51+09:00</updated><id>http://localhost:4000/cs/algorithm/exhaustive-search</id><content type="html" xml:base="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#완전탐색" id="markdown-toc-완전탐색">완전탐색</a></li>
</ul>

<h2 id="완전탐색">완전탐색</h2>

<p>완전탐색 알고리즘은 가능한 모든 경우의 수를 탐색하여 문제를 해결하는 방식이다.<br />
모든 가능성을 시도하면서 필요한 답을 찾아내는 방식으로 동작한다.</p>

<p>이는 간단하고 직관적이지만, 많은 경우에 있어 효율성이 낮은 편이다.</p>

<p>완전 탐색의 특징으로는 다음이 있다:</p>

<ul>
  <li>
    <p><b>모든 가능한 경우 고려:</b> 문제에 대한 모든 가능한 경우의 수를 검사한다.</p>
  </li>
  <li>
    <p><b>순서대로 나열:</b> 일반적으로 완전 탐색은 경우의 수를 나열하며 해를 찾는다.</p>
  </li>
  <li>
    <p><b>쉽게 이해 가능:</b> 구현이 간단하고 직관적이지만 효율성이 떨어진다.</p>
  </li>
</ul>

<p>선형 구조를 완전 탐색하는 순차 탐색 방식과 비선형 구조를 완전 탐색하는 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이<br />
완전 탐색에 사용되는 가장 기본적인 도구들이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="algorithm" /></entry><entry><title type="html">Exceptional Control Flow</title><link href="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/" rel="alternate" type="text/html" title="Exceptional Control Flow" /><published>2024-02-08T19:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science,/os/exceptional_control_flow</id><content type="html" xml:base="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ecf" id="markdown-toc-ecf">ECF</a></li>
  <li><a href="#예외상황" id="markdown-toc-예외상황">예외상황</a>    <ul>
      <li><a href="#인터럽트-1" id="markdown-toc-인터럽트-1">인터럽트</a></li>
      <li><a href="#트랩-1" id="markdown-toc-트랩-1">트랩</a></li>
      <li><a href="#오류-1" id="markdown-toc-오류-1">오류</a></li>
      <li><a href="#중단-1" id="markdown-toc-중단-1">중단</a></li>
    </ul>
  </li>
  <li><a href="#시스템-콜" id="markdown-toc-시스템-콜">시스템 콜</a></li>
</ul>

<h2 id="ecf">ECF</h2>

<p>예외적인 제어흐름 (exceptional control flow, ECF)은 운영체제가 입출력, 프로세스, 가상메모리 등을 구연하기 위해 사용하는 기본 메커니즘이다.<br />
ECF를 이해하면 응용 프로그램들이 어떻게 운영체제와 상호작용 하는지 이해하는데에 도움이 된다. 
응용 프로그램은 트랩 또는 시스템 콜이라고 알려진 ECF의 한 가지 형태를 사용해서 운영체제로부터 서비스를 요청한다.</p>

<h2 id="예외상황">예외상황</h2>

<p>예외상황은 예외적인 제어흐름의 한가지 형태이며, 하드웨어와 운영체제에 의해 구현된다.<br />
프로세서 상태의 변화에 대한 대응으로, ECF의 갑작스런 변화이다.</p>

<p>상태 변화는 이벤트라고 하는데 이 이벤트는 현재 인스트럭션의 실행에 직접적으로 관련될 수도 있다.
예로, 산술 오버플로우가 발생했다거나, 어떠한 인스트럭션이 divide by zero를 시도하는 것이 이러한 경우에 해당된다.<br />
또는, 현재 인스트럭션의 실행과 관련이 없을 수도 있는데, 예시로는 시스템 타이머가 정지하는 경우가 있겠다.</p>

<p>어떤 경우에서든 이러한 이벤트가 발생을 했다면, 그리고 프로세서가 이를 감지한다면,<br />
예외 테이블이라고 하는 점프 테이블을 통해 예외처리 핸들러라는 운영체제 서브루틴으로 간접 프로시저 콜을 한다. 
예외처리 핸들러는 발생한 이벤트의 종류에 따라 구분되며, 특정 종류의 이벤트를 처리하기 위해 설계된 서브루틴이다.</p>

<p>예외처리 핸들러가 처리를 한 후에는 이벤트의 종류에 따라 핸들러는 다음 세 가지 중 하나를 한다:</p>

<ol>
  <li>
    <p>제어를 현재의 인스트럭션으로 돌려준다.<br />
여기서 현재의 인스트럭션이라 함은, 이벤트 발생 시점에 실행되고 있던 인스트럭션을 지칭한다.</p>
  </li>
  <li>
    <p>제어를 다음 인스트럭션으로 돌려준다. 
여기서 다음 인스트럭션은 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션이다.</p>
  </li>
  <li>
    <p>중단된 프로그램을 종료한다.</p>
  </li>
</ol>

<p>예외상황은 네 가지의 종류로 구분된다:</p>

<h3 id="인터럽트-1">인터럽트</h3>

<h3 id="트랩-1">트랩</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>트랩은 어떤 인스트럭션을 실행한 결과로 발생하는 의도적인 예외상황이다. 
트랩 핸들러는 제어를 다음 인스트럭션으로 돌려준다. 
트랩의 가장 종요한 사용은 시스템 콜이라는 인터페이스를 제공하는 것이다. 
</code></pre></div></div>

<h3 id="오류-1">오류</h3>

<h3 id="중단-1">중단</h3>

<h2 id="시스템-콜">시스템 콜</h2>

<p>시스템 콜, 또는 시스템 호출은 응용 프로그램이 운영체제의 커널에 서비스를 요청하기 위한 메커니즘이다.<br />
여기서 서비스라 함은, 다음을 포함한다:</p>

<ul>
  <li>파일 작업 수행</li>
  <li>프로세스 생성 및 관리</li>
  <li>메모리 관리</li>
  <li>입출력 연산 처리</li>
</ul>

<p>프로그램이 운영 체제와의 상호작용을 필요로 하는 작업을 수행해야 할 경우, 프로그램은 시스템 콜을 한다.<br />
이렇게 함으로 프로그램은 코드를 커널 모드에서 실행할 수 있게 되며 시스템 자원에 직접 접근할 수 있게 된다.
시스템 콜 인터페이스는 사용자 수준 프로그램이 커널과 통신할 수 있는 표준화된 방식을 제공한다.</p>

<p>프로그래머의 관점에서 시스템 콜은 보통의 함수 호출과 동일하다 (실제 구현은 매우 다르다). 
다만, 보통의 함수와 달리 시스템 콜은 사용자 모드가 아닌 커널 모드에서 돌아가며,<br />
이로 인해 커널 내에서 정의된 스택에 접근함으로 더욱 많은 권한을 가진 인스트럭션을 실행할 수 있게 된다.</p>

<p>x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해 제공된다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science," /><category term="OS" /><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" /><media:content medium="image" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Explicit &amp;amp; Implicit Free List</title><link href="http://localhost:4000/computer_science/2024-02-07-free_list/" rel="alternate" type="text/html" title="Explicit &amp;amp; Implicit Free List" /><published>2024-02-07T21:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/free_list</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-free_list/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#가용-리스트" id="markdown-toc-가용-리스트">가용 리스트</a>    <ul>
      <li><a href="#명시적-가용-리스트-1" id="markdown-toc-명시적-가용-리스트-1">명시적 가용 리스트</a></li>
      <li><a href="#묵시적-가용-리스트-1" id="markdown-toc-묵시적-가용-리스트-1">묵시적 가용 리스트</a></li>
      <li><a href="#차이-1" id="markdown-toc-차이-1">차이</a></li>
    </ul>
  </li>
</ul>

<h2 id="가용-리스트">가용 리스트</h2>

<p>가용 리스트는 메모리 할당 및 해제를 관리하기 위한 자료구조이며,<br />
동적으로 할당될 수 있는 메모리 블록을 추적하는 데 사용된다.<br />
즉, 전에 할당되었지만 반환되어 가용 가능한 메모리 블록에 대한 정보를 저장한다.<br />
가용 리스트는 일반적으로 운영 체제의 메모리 관리자 또는 프로그래밍 언어의 런타임 시스템에서 사용된다.</p>

<h3 id="명시적-가용-리스트-1">명시적 가용 리스트</h3>

<p>명시적 가용 리스트에서의 반환된 모든 메모리 블럭은 포인터 또는 참조 등의 추가적인 정보를 가지고 있으며, 
이는 다음 가용 가능한 메모리 블록을 명시적으로 나타낸다. <br />
명시적 가용 리스트는 연결 리스트 또는 다른 자료구조를 유지하며, 해당 자료구조의 각 노드에게 반환된 메모리 블록을 나타내게 함으로 
다음의 가용 가능 메모리 블록을 가르키게 한다.<br />
메모리 블록이 반환되는 시점에 할당기는 적절한 포인터 또는 참조를 갱신하여 해당 블록을 명시적 가용 리스트에 추가한다.<br />
메모리를 할당하기 위해 할당기는 명시적 가용 리스트를 탐색하여 충분한 크기의 메모리 블록을 찾고,
해당 메모리 블록을 가용 리스트에서 제거한 후 메모리를 요청한 프로세스에 할당한다.</p>

<h3 id="묵시적-가용-리스트-1">묵시적 가용 리스트</h3>

<p>묵시적 가용 리스트에서는 할당기가 할당 및 반환된 메모리 블록을 명시적인 포인터 또는 참조 없이 관리한다. <br />
반환된 메모리 블록은 직접적인 포인터나 참조 대신 힙 내에서의 각각의 크기와 위치로 구분된다.<br />
메모리 블록이 반환되는 시점에 할당기는 이를 가용 가능한 것으로 표시하며 인접한 반환된 블록들과 합쳐 더 큰 가용 가능한 블록을 만든다. 
메모리를 할당하기 위해 할당기는 해당 태스크에 사용되기 적절한 메모리 블록을 찾기 위해 크기와 위치를 고려하여 힙을 탐색 및 찾은 후 메모리를 할당한다.</p>

<h3 id="차이-1">차이</h3>

<p>명시적 가용 리스트와 묵시적 가용 리스트의 주요 차이는 가용 가능한 메모리 블록들의 정보를 관리하는 방식에 있다. <br />
명시적 가용 리스트는 직접적인 포인터 또는 참조를 사용하여 반환된 메모리 블록을 연결하여 관리하며,
추가적인 포인터 또는 참조를 저장해야 하기 때문에 일반적으로 더 많은 메모리를 필요로 한다.  <br />
이에 반해, 묵시적 가용 리스트는 힙 내에서의 메모리 블록의 위치와 크기에 의존하여 메모리의 가용 가능성을 판단하며, <br />
메모리 할당 시 적절한 메모리 블록을 찾기 위해 더 많은 시간(계산)이 필요하다 (힙이 파편화되어 있으면 더욱 그렇다).</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">동적 메모리 할당기</title><link href="http://localhost:4000/coding/baekjoon/2024-02-07-allocator/" rel="alternate" type="text/html" title="동적 메모리 할당기" /><published>2024-02-07T20:00:00+09:00</published><updated>2024-02-20T23:25:29+09:00</updated><id>http://localhost:4000/coding/baekjoon/allocator</id><content type="html" xml:base="http://localhost:4000/coding/baekjoon/2024-02-07-allocator/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동적-메모리-할당기" id="markdown-toc-동적-메모리-할당기">동적 메모리 할당기</a>    <ul>
      <li><a href="#명시적-할당기-1" id="markdown-toc-명시적-할당기-1">명시적 할당기</a></li>
      <li><a href="#묵시적-할당기-1" id="markdown-toc-묵시적-할당기-1">묵시적 할당기</a></li>
    </ul>
  </li>
</ul>

<h2 id="동적-메모리-할당기">동적 메모리 할당기</h2>

<p>저수준의 mmap과 munmap 함수들을 사용하여 가상메모리의 영역을 생성하고 삭제할 수 있지만, <br />
대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때 <i>동적 메모리 할당기</i>라는 것을 사용하는 것이 편리하고 호환성이 좋다고 여겨진다.</p>

<p>동적 메모리 할당기는 <i>heap</i>, 즉 프로세스의 가상 메모리 영역을 관리한다. <br />
할당기는 힙을 다양한 크기의 블록들의 집합으로 관리하며, 이 때 각 블록은 할당되었거나 가용한 가상메모리의 연속적인 묶음이다.</p>

<p>할당기에는 두 개의 기본 유형이 있다:</p>
<ul>
  <li>명시적 할당기</li>
  <li>묵시적 할당기</li>
</ul>

<p>두 유형 모두 할당시에는 명시적으로 블록을 할당하도록 요구하지만, 할당된 블록을 반환하는 방식에 차이가 있다.</p>

<h3 id="명시적-할당기-1">명시적 할당기</h3>

<p>명시적 할당기는 할당된 블록의 반환하기 위해 애플리케이션이 명시적으로 요구해야 한다. <br />
예시로는 C 표준 라이브러리의 <code class="language-plaintext highlighter-rouge">malloc()</code> 함수가 있다.<br />
C 프로그램은 malloc 함수를 호출해서 블록을 할당하며, 할당된 블록을 반환하기 위해서는 <code class="language-plaintext highlighter-rouge">free()</code>함수를 호출해야 한다. <br />
C++ 에서는 <code class="language-plaintext highlighter-rouge">new()</code>와 <code class="language-plaintext highlighter-rouge">delete()</code>가 있다.</p>

<h3 id="묵시적-할당기-1">묵시적 할당기</h3>

<p>묵시적 할당기는 할당된 블록이 더 이상 프로그램에 의해 사용되지 않는지 할당기가 검출할 수 있을 것을 요구하며, <br />
이러한 검출을 통해 블록의 반환이 별도의 함수 호출 없이 이루어진다.<br />
묵시적 할당기는 <i>garbage collector</i>라고도 알려져 있으며, 자동으로 사용하지 않는 할당된 블록을 반환하는 작업을 가비지 컬렉션이라고 부른다. <br />
List, ML, Java같은 고급 언어는 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용한다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="coding" /><category term="baekjoon" /></entry><entry><title type="html">MMAP &amp;amp; MUNMAP</title><link href="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/" rel="alternate" type="text/html" title="MMAP &amp;amp; MUNMAP" /><published>2024-02-07T15:43:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/mmap_munmap</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#mmap" id="markdown-toc-mmap">MMAP</a>    <ul>
      <li><a href="#address-1" id="markdown-toc-address-1">address</a></li>
      <li><a href="#length-1" id="markdown-toc-length-1">length</a></li>
      <li><a href="#protect-1" id="markdown-toc-protect-1">protect</a></li>
      <li><a href="#flags-1" id="markdown-toc-flags-1">flags</a></li>
      <li><a href="#filedes" id="markdown-toc-filedes">filedes</a></li>
      <li><a href="#offset-1" id="markdown-toc-offset-1">offset</a></li>
    </ul>
  </li>
  <li><a href="#munmap" id="markdown-toc-munmap">MUNMAP</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수와 <code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상 메모리의 영역들을 생성하고 삭제할 수 있게 해주는 함수들이다.</p>

<h2 id="mmap">MMAP</h2>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수는 Memory Map이라는 뜻을 가지며, 말 그대로 메모리를 매핑하여 가상 메모리의 영역을 생성하고 삭제할 수 있게 해준다.
커널에 새 가상메모리 영역을 생성해 줄 것을 요청하며, 객체들을 이 영역으로 매핑할 수 있다.</p>

<p>이를 사용해 성공적으로 파일을 메모리에 매핑한다면, 해당 메모리의 주소값이 반환된다.<br />
<code class="language-plaintext highlighter-rouge">mmap()</code>함수는 다음의 6 인자들을 받는다.  <br />
<code class="language-plaintext highlighter-rouge">void *address</code>, <code class="language-plaintext highlighter-rouge">size_t length</code>, <code class="language-plaintext highlighter-rouge">int protect</code>, <code class="language-plaintext highlighter-rouge">int flags</code>, <code class="language-plaintext highlighter-rouge">int filedes</code>, <code class="language-plaintext highlighter-rouge">off_t offset</code></p>

<h3 id="address-1">address</h3>

<p>이 인자는 매핑에 선호하는 시작 주소를 함수로 전달하며, 대개 <code class="language-plaintext highlighter-rouge">NULL</code>로 명시한다.<br />
다른 매핑이 해당 주소에 존재하지 않다면 커널은 근처의 페이지 영역을 선택하여 매핑을 한다.
해당 인자에 <code class="language-plaintext highlighter-rouge">NULL</code>이 패스된다면 커널은 적절한 위치를 찾아 매핑을 한다.</p>

<h3 id="length-1">length</h3>

<p>매핑 될 바이트의 수이다.</p>

<h3 id="protect-1">protect</h3>

<p>이 인자는 어떤 접근이 허용되는지 제어하기 위해 사용된다.<br />
파일에 대응되는 메모리 영역의 보호 특성을 결정하기 위해 다음의 비트들이 있으며,
해당 비트들의 논리 OR 형태로도 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">PROT_EXEC</code> : 실행 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_READ</code> : 읽기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_WRITE</code> : 쓰기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_NONE</code> : 접근 불가능한 페이지</p>

<h3 id="flags-1">flags</h3>

<p>매핑의 유형과 동작 구성 요소를 결정하는 값이다.
이는 대응되는 페이지 복사본에 대한 수정이 해당 프로세스에서만 보일 것인지, 아니면 다른 참조하는 프로세스와 공유할 것인지를 설정한다.</p>

<p><code class="language-plaintext highlighter-rouge">MAP_SHARED</code> : 이 플래그는 매핑을 다른 모든 프로세스들과 공유하기 위해 사용된다. 매핑된 영역에 대한 수정은 파일에 다시 쓰여진다.<br />
<code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code> : 해당 플래그가 사용되면 매핑은 다른 프로세스들에게 보이지 않으며, 변경점들 또한 파일에 쓰여지지 않는다.<br />
<code class="language-plaintext highlighter-rouge">MAP_ANONYMOUS || MAP_ANON</code> : 익명의 매핑을 만들며, 파일 디스크립터로 인식하지 않는다. 어떠한 파일에도 연결되지 않으며, 힙을 늘리는 방식으로 사용된다.<br />
<code class="language-plaintext highlighter-rouge">MAP_FIXED</code> : 지정된 주소 이외의 다른 주소를 선택하지 않는다. 이 때, 지정된 주소가 사용될 수 없다면 mmap()은 실패한다.</p>

<h3 id="filedes">filedes</h3>

<p>매핑될 파일 디스크립터이다.</p>

<h3 id="offset-1">offset</h3>

<p>매핑할 때, 옮길 데이터의 시작점을 지정하는 인수이다.</p>

<h2 id="munmap">MUNMAP</h2>

<p><code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상메모리의 영역들을 삭제한다.</p>

<p>인수로는 <code class="language-plaintext highlighter-rouge">void *start</code>와 <code class="language-plaintext highlighter-rouge">size_t length</code>를 받으며,
이는 가상주소 <code class="language-plaintext highlighter-rouge">start</code>부터 <code class="language-plaintext highlighter-rouge">length</code>바이트로 이루어진 영역을 삭제하라는 말이다.<br />
<b>이후, 삭제된 영역으로의 참조는 세그먼트 오류를 발생시킨다.</b></p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">가상화</title><link href="http://localhost:4000/computer/science/2024-02-03-first-post/" rel="alternate" type="text/html" title="가상화" /><published>2024-02-03T13:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer/science/first-post</id><content type="html" xml:base="http://localhost:4000/computer/science/2024-02-03-first-post/"><![CDATA[<p>가상화란 컴퓨터 리소스의 추상화를 의미한다.</p>

<p>추상화라는 단어가 CS에는 매우 자주 등장하는 듯 한데, 개인적으로 무언가를 추상화 하려면 이미지가 중요하다고 생각해서 이미지를 찾아보니 이런 걸 찾았다:</p>

<p><img />&lt;/img&gt;</p>

<p>가상화란,
하나의 물리 리소스를 여러개의 논리 리소스처럼 기능 시키거나,<br />
여러 개의 물리 리소스를 하나의 논리 리소스처럼 기능케 한다.</p>

<p>이게 무슨 말이냐면,<br />
하나의 실물 컴퓨팅 자원을 마치 여러 개인 것처럼 가상으로 쪼개서 사용하거나,<br />
여러 개의 실물 컴퓨팅 자원들을 묶어서 하나의 자원인 것처럼 사용하겠다는 것이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer" /><category term="Science" /><summary type="html"><![CDATA[가상화란 컴퓨터 리소스의 추상화를 의미한다.]]></summary></entry></feed>