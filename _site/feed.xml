<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-02-20T23:28:53+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jae’s Blog</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><entry><title type="html">2156 - 포도주 시식</title><link href="http://localhost:4000/coding/baekjoon/2024-02-20-boj2156/" rel="alternate" type="text/html" title="2156 - 포도주 시식" /><published>2024-02-20T13:00:00+09:00</published><updated>2024-02-20T23:28:47+09:00</updated><id>http://localhost:4000/coding/baekjoon/boj2156</id><content type="html" xml:base="http://localhost:4000/coding/baekjoon/2024-02-20-boj2156/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#문제-설명" id="markdown-toc-문제-설명">문제 설명</a></li>
</ul>

<h2 id="문제-설명">문제 설명</h2>

<p>효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.</p>

<p>포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.</p>

<p>예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.</p>

<p>입력
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.</p>

<p class="lead">출력
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.</p>

<p>hello</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="coding" /><category term="baekjoon" /><summary type="html"><![CDATA[백준 2156 난이도: 실버 1 알고리즘: 동적계획법]]></summary></entry><entry><title type="html">완전탐색</title><link href="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/" rel="alternate" type="text/html" title="완전탐색" /><published>2024-02-17T20:00:00+09:00</published><updated>2024-02-20T17:06:51+09:00</updated><id>http://localhost:4000/cs/algorithm/exhaustive-search</id><content type="html" xml:base="http://localhost:4000/cs/algorithm/2024-02-17-exhaustive-search/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#완전탐색" id="markdown-toc-완전탐색">완전탐색</a></li>
</ul>

<h2 id="완전탐색">완전탐색</h2>

<p>완전탐색 알고리즘은 가능한 모든 경우의 수를 탐색하여 문제를 해결하는 방식이다.<br />
모든 가능성을 시도하면서 필요한 답을 찾아내는 방식으로 동작한다.</p>

<p>이는 간단하고 직관적이지만, 많은 경우에 있어 효율성이 낮은 편이다.</p>

<p>완전 탐색의 특징으로는 다음이 있다:</p>

<ul>
  <li>
    <p><b>모든 가능한 경우 고려:</b> 문제에 대한 모든 가능한 경우의 수를 검사한다.</p>
  </li>
  <li>
    <p><b>순서대로 나열:</b> 일반적으로 완전 탐색은 경우의 수를 나열하며 해를 찾는다.</p>
  </li>
  <li>
    <p><b>쉽게 이해 가능:</b> 구현이 간단하고 직관적이지만 효율성이 떨어진다.</p>
  </li>
</ul>

<p>선형 구조를 완전 탐색하는 순차 탐색 방식과 비선형 구조를 완전 탐색하는 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)이<br />
완전 탐색에 사용되는 가장 기본적인 도구들이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="algorithm" /></entry><entry><title type="html">Ethernet</title><link href="http://localhost:4000/2024-02-15-ethernet/" rel="alternate" type="text/html" title="Ethernet" /><published>2024-02-15T00:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/ethernet</id><content type="html" xml:base="http://localhost:4000/2024-02-15-ethernet/"><![CDATA[]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Exceptional Control Flow</title><link href="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/" rel="alternate" type="text/html" title="Exceptional Control Flow" /><published>2024-02-08T19:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science,/os/exceptional_control_flow</id><content type="html" xml:base="http://localhost:4000/computer_science,/os/2024-02-08-exceptional_control_flow/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ecf" id="markdown-toc-ecf">ECF</a></li>
  <li><a href="#예외상황" id="markdown-toc-예외상황">예외상황</a>    <ul>
      <li><a href="#인터럽트-1" id="markdown-toc-인터럽트-1">인터럽트</a></li>
      <li><a href="#트랩-1" id="markdown-toc-트랩-1">트랩</a></li>
      <li><a href="#오류-1" id="markdown-toc-오류-1">오류</a></li>
      <li><a href="#중단-1" id="markdown-toc-중단-1">중단</a></li>
    </ul>
  </li>
  <li><a href="#시스템-콜" id="markdown-toc-시스템-콜">시스템 콜</a></li>
</ul>

<h2 id="ecf">ECF</h2>

<p>예외적인 제어흐름 (exceptional control flow, ECF)은 운영체제가 입출력, 프로세스, 가상메모리 등을 구연하기 위해 사용하는 기본 메커니즘이다.<br />
ECF를 이해하면 응용 프로그램들이 어떻게 운영체제와 상호작용 하는지 이해하는데에 도움이 된다. 
응용 프로그램은 트랩 또는 시스템 콜이라고 알려진 ECF의 한 가지 형태를 사용해서 운영체제로부터 서비스를 요청한다.</p>

<h2 id="예외상황">예외상황</h2>

<p>예외상황은 예외적인 제어흐름의 한가지 형태이며, 하드웨어와 운영체제에 의해 구현된다.<br />
프로세서 상태의 변화에 대한 대응으로, ECF의 갑작스런 변화이다.</p>

<p>상태 변화는 이벤트라고 하는데 이 이벤트는 현재 인스트럭션의 실행에 직접적으로 관련될 수도 있다.
예로, 산술 오버플로우가 발생했다거나, 어떠한 인스트럭션이 divide by zero를 시도하는 것이 이러한 경우에 해당된다.<br />
또는, 현재 인스트럭션의 실행과 관련이 없을 수도 있는데, 예시로는 시스템 타이머가 정지하는 경우가 있겠다.</p>

<p>어떤 경우에서든 이러한 이벤트가 발생을 했다면, 그리고 프로세서가 이를 감지한다면,<br />
예외 테이블이라고 하는 점프 테이블을 통해 예외처리 핸들러라는 운영체제 서브루틴으로 간접 프로시저 콜을 한다. 
예외처리 핸들러는 발생한 이벤트의 종류에 따라 구분되며, 특정 종류의 이벤트를 처리하기 위해 설계된 서브루틴이다.</p>

<p>예외처리 핸들러가 처리를 한 후에는 이벤트의 종류에 따라 핸들러는 다음 세 가지 중 하나를 한다:</p>

<ol>
  <li>
    <p>제어를 현재의 인스트럭션으로 돌려준다.<br />
여기서 현재의 인스트럭션이라 함은, 이벤트 발생 시점에 실행되고 있던 인스트럭션을 지칭한다.</p>
  </li>
  <li>
    <p>제어를 다음 인스트럭션으로 돌려준다. 
여기서 다음 인스트럭션은 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션이다.</p>
  </li>
  <li>
    <p>중단된 프로그램을 종료한다.</p>
  </li>
</ol>

<p>예외상황은 네 가지의 종류로 구분된다:</p>

<h3 id="인터럽트-1">인터럽트</h3>

<h3 id="트랩-1">트랩</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>트랩은 어떤 인스트럭션을 실행한 결과로 발생하는 의도적인 예외상황이다. 
트랩 핸들러는 제어를 다음 인스트럭션으로 돌려준다. 
트랩의 가장 종요한 사용은 시스템 콜이라는 인터페이스를 제공하는 것이다. 
</code></pre></div></div>

<h3 id="오류-1">오류</h3>

<h3 id="중단-1">중단</h3>

<h2 id="시스템-콜">시스템 콜</h2>

<p>시스템 콜, 또는 시스템 호출은 응용 프로그램이 운영체제의 커널에 서비스를 요청하기 위한 메커니즘이다.<br />
여기서 서비스라 함은, 다음을 포함한다:</p>

<ul>
  <li>파일 작업 수행</li>
  <li>프로세스 생성 및 관리</li>
  <li>메모리 관리</li>
  <li>입출력 연산 처리</li>
</ul>

<p>프로그램이 운영 체제와의 상호작용을 필요로 하는 작업을 수행해야 할 경우, 프로그램은 시스템 콜을 한다.<br />
이렇게 함으로 프로그램은 코드를 커널 모드에서 실행할 수 있게 되며 시스템 자원에 직접 접근할 수 있게 된다.
시스템 콜 인터페이스는 사용자 수준 프로그램이 커널과 통신할 수 있는 표준화된 방식을 제공한다.</p>

<p>프로그래머의 관점에서 시스템 콜은 보통의 함수 호출과 동일하다 (실제 구현은 매우 다르다). 
다만, 보통의 함수와 달리 시스템 콜은 사용자 모드가 아닌 커널 모드에서 돌아가며,<br />
이로 인해 커널 내에서 정의된 스택에 접근함으로 더욱 많은 권한을 가진 인스트럭션을 실행할 수 있게 된다.</p>

<p>x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해 제공된다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science," /><category term="OS" /><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" /><media:content medium="image" url="https://koyo.kr/post/csapp-ecf-exception/exception-handling.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Explicit &amp;amp; Implicit Free List</title><link href="http://localhost:4000/computer_science/2024-02-07-free_list/" rel="alternate" type="text/html" title="Explicit &amp;amp; Implicit Free List" /><published>2024-02-07T21:00:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/free_list</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-free_list/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#가용-리스트" id="markdown-toc-가용-리스트">가용 리스트</a>    <ul>
      <li><a href="#명시적-가용-리스트-1" id="markdown-toc-명시적-가용-리스트-1">명시적 가용 리스트</a></li>
      <li><a href="#묵시적-가용-리스트-1" id="markdown-toc-묵시적-가용-리스트-1">묵시적 가용 리스트</a></li>
      <li><a href="#차이-1" id="markdown-toc-차이-1">차이</a></li>
    </ul>
  </li>
</ul>

<h2 id="가용-리스트">가용 리스트</h2>

<p>가용 리스트는 메모리 할당 및 해제를 관리하기 위한 자료구조이며,<br />
동적으로 할당될 수 있는 메모리 블록을 추적하는 데 사용된다.<br />
즉, 전에 할당되었지만 반환되어 가용 가능한 메모리 블록에 대한 정보를 저장한다.<br />
가용 리스트는 일반적으로 운영 체제의 메모리 관리자 또는 프로그래밍 언어의 런타임 시스템에서 사용된다.</p>

<h3 id="명시적-가용-리스트-1">명시적 가용 리스트</h3>

<p>명시적 가용 리스트에서의 반환된 모든 메모리 블럭은 포인터 또는 참조 등의 추가적인 정보를 가지고 있으며, 
이는 다음 가용 가능한 메모리 블록을 명시적으로 나타낸다. <br />
명시적 가용 리스트는 연결 리스트 또는 다른 자료구조를 유지하며, 해당 자료구조의 각 노드에게 반환된 메모리 블록을 나타내게 함으로 
다음의 가용 가능 메모리 블록을 가르키게 한다.<br />
메모리 블록이 반환되는 시점에 할당기는 적절한 포인터 또는 참조를 갱신하여 해당 블록을 명시적 가용 리스트에 추가한다.<br />
메모리를 할당하기 위해 할당기는 명시적 가용 리스트를 탐색하여 충분한 크기의 메모리 블록을 찾고,
해당 메모리 블록을 가용 리스트에서 제거한 후 메모리를 요청한 프로세스에 할당한다.</p>

<h3 id="묵시적-가용-리스트-1">묵시적 가용 리스트</h3>

<p>묵시적 가용 리스트에서는 할당기가 할당 및 반환된 메모리 블록을 명시적인 포인터 또는 참조 없이 관리한다. <br />
반환된 메모리 블록은 직접적인 포인터나 참조 대신 힙 내에서의 각각의 크기와 위치로 구분된다.<br />
메모리 블록이 반환되는 시점에 할당기는 이를 가용 가능한 것으로 표시하며 인접한 반환된 블록들과 합쳐 더 큰 가용 가능한 블록을 만든다. 
메모리를 할당하기 위해 할당기는 해당 태스크에 사용되기 적절한 메모리 블록을 찾기 위해 크기와 위치를 고려하여 힙을 탐색 및 찾은 후 메모리를 할당한다.</p>

<h3 id="차이-1">차이</h3>

<p>명시적 가용 리스트와 묵시적 가용 리스트의 주요 차이는 가용 가능한 메모리 블록들의 정보를 관리하는 방식에 있다. <br />
명시적 가용 리스트는 직접적인 포인터 또는 참조를 사용하여 반환된 메모리 블록을 연결하여 관리하며,
추가적인 포인터 또는 참조를 저장해야 하기 때문에 일반적으로 더 많은 메모리를 필요로 한다.  <br />
이에 반해, 묵시적 가용 리스트는 힙 내에서의 메모리 블록의 위치와 크기에 의존하여 메모리의 가용 가능성을 판단하며, <br />
메모리 할당 시 적절한 메모리 블록을 찾기 위해 더 많은 시간(계산)이 필요하다 (힙이 파편화되어 있으면 더욱 그렇다).</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">동적 메모리 할당기</title><link href="http://localhost:4000/coding/baekjoon/2024-02-07-allocator/" rel="alternate" type="text/html" title="동적 메모리 할당기" /><published>2024-02-07T20:00:00+09:00</published><updated>2024-02-20T23:25:29+09:00</updated><id>http://localhost:4000/coding/baekjoon/allocator</id><content type="html" xml:base="http://localhost:4000/coding/baekjoon/2024-02-07-allocator/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동적-메모리-할당기" id="markdown-toc-동적-메모리-할당기">동적 메모리 할당기</a>    <ul>
      <li><a href="#명시적-할당기-1" id="markdown-toc-명시적-할당기-1">명시적 할당기</a></li>
      <li><a href="#묵시적-할당기-1" id="markdown-toc-묵시적-할당기-1">묵시적 할당기</a></li>
    </ul>
  </li>
</ul>

<h2 id="동적-메모리-할당기">동적 메모리 할당기</h2>

<p>저수준의 mmap과 munmap 함수들을 사용하여 가상메모리의 영역을 생성하고 삭제할 수 있지만, <br />
대개 추가적인 가상메모리를 런타임에 획득할 필요가 있을 때 <i>동적 메모리 할당기</i>라는 것을 사용하는 것이 편리하고 호환성이 좋다고 여겨진다.</p>

<p>동적 메모리 할당기는 <i>heap</i>, 즉 프로세스의 가상 메모리 영역을 관리한다. <br />
할당기는 힙을 다양한 크기의 블록들의 집합으로 관리하며, 이 때 각 블록은 할당되었거나 가용한 가상메모리의 연속적인 묶음이다.</p>

<p>할당기에는 두 개의 기본 유형이 있다:</p>
<ul>
  <li>명시적 할당기</li>
  <li>묵시적 할당기</li>
</ul>

<p>두 유형 모두 할당시에는 명시적으로 블록을 할당하도록 요구하지만, 할당된 블록을 반환하는 방식에 차이가 있다.</p>

<h3 id="명시적-할당기-1">명시적 할당기</h3>

<p>명시적 할당기는 할당된 블록의 반환하기 위해 애플리케이션이 명시적으로 요구해야 한다. <br />
예시로는 C 표준 라이브러리의 <code class="language-plaintext highlighter-rouge">malloc()</code> 함수가 있다.<br />
C 프로그램은 malloc 함수를 호출해서 블록을 할당하며, 할당된 블록을 반환하기 위해서는 <code class="language-plaintext highlighter-rouge">free()</code>함수를 호출해야 한다. <br />
C++ 에서는 <code class="language-plaintext highlighter-rouge">new()</code>와 <code class="language-plaintext highlighter-rouge">delete()</code>가 있다.</p>

<h3 id="묵시적-할당기-1">묵시적 할당기</h3>

<p>묵시적 할당기는 할당된 블록이 더 이상 프로그램에 의해 사용되지 않는지 할당기가 검출할 수 있을 것을 요구하며, <br />
이러한 검출을 통해 블록의 반환이 별도의 함수 호출 없이 이루어진다.<br />
묵시적 할당기는 <i>garbage collector</i>라고도 알려져 있으며, 자동으로 사용하지 않는 할당된 블록을 반환하는 작업을 가비지 컬렉션이라고 부른다. <br />
List, ML, Java같은 고급 언어는 할당된 블록들을 반환시키기 위해 가비지 컬렉션을 사용한다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="coding" /><category term="baekjoon" /></entry><entry><title type="html">MMAP &amp;amp; MUNMAP</title><link href="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/" rel="alternate" type="text/html" title="MMAP &amp;amp; MUNMAP" /><published>2024-02-07T15:43:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer_science/mmap_munmap</id><content type="html" xml:base="http://localhost:4000/computer_science/2024-02-07-mmap_munmap/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#mmap" id="markdown-toc-mmap">MMAP</a>    <ul>
      <li><a href="#address-1" id="markdown-toc-address-1">address</a></li>
      <li><a href="#length-1" id="markdown-toc-length-1">length</a></li>
      <li><a href="#protect-1" id="markdown-toc-protect-1">protect</a></li>
      <li><a href="#flags-1" id="markdown-toc-flags-1">flags</a></li>
      <li><a href="#filedes" id="markdown-toc-filedes">filedes</a></li>
      <li><a href="#offset-1" id="markdown-toc-offset-1">offset</a></li>
    </ul>
  </li>
  <li><a href="#munmap" id="markdown-toc-munmap">MUNMAP</a></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수와 <code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상 메모리의 영역들을 생성하고 삭제할 수 있게 해주는 함수들이다.</p>

<h2 id="mmap">MMAP</h2>

<p><code class="language-plaintext highlighter-rouge">mmap()</code>함수는 Memory Map이라는 뜻을 가지며, 말 그대로 메모리를 매핑하여 가상 메모리의 영역을 생성하고 삭제할 수 있게 해준다.
커널에 새 가상메모리 영역을 생성해 줄 것을 요청하며, 객체들을 이 영역으로 매핑할 수 있다.</p>

<p>이를 사용해 성공적으로 파일을 메모리에 매핑한다면, 해당 메모리의 주소값이 반환된다.<br />
<code class="language-plaintext highlighter-rouge">mmap()</code>함수는 다음의 6 인자들을 받는다.  <br />
<code class="language-plaintext highlighter-rouge">void *address</code>, <code class="language-plaintext highlighter-rouge">size_t length</code>, <code class="language-plaintext highlighter-rouge">int protect</code>, <code class="language-plaintext highlighter-rouge">int flags</code>, <code class="language-plaintext highlighter-rouge">int filedes</code>, <code class="language-plaintext highlighter-rouge">off_t offset</code></p>

<h3 id="address-1">address</h3>

<p>이 인자는 매핑에 선호하는 시작 주소를 함수로 전달하며, 대개 <code class="language-plaintext highlighter-rouge">NULL</code>로 명시한다.<br />
다른 매핑이 해당 주소에 존재하지 않다면 커널은 근처의 페이지 영역을 선택하여 매핑을 한다.
해당 인자에 <code class="language-plaintext highlighter-rouge">NULL</code>이 패스된다면 커널은 적절한 위치를 찾아 매핑을 한다.</p>

<h3 id="length-1">length</h3>

<p>매핑 될 바이트의 수이다.</p>

<h3 id="protect-1">protect</h3>

<p>이 인자는 어떤 접근이 허용되는지 제어하기 위해 사용된다.<br />
파일에 대응되는 메모리 영역의 보호 특성을 결정하기 위해 다음의 비트들이 있으며,
해당 비트들의 논리 OR 형태로도 사용 가능하다.</p>

<p><code class="language-plaintext highlighter-rouge">PROT_EXEC</code> : 실행 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_READ</code> : 읽기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_WRITE</code> : 쓰기 가능한 페이지<br />
<code class="language-plaintext highlighter-rouge">PROT_NONE</code> : 접근 불가능한 페이지</p>

<h3 id="flags-1">flags</h3>

<p>매핑의 유형과 동작 구성 요소를 결정하는 값이다.
이는 대응되는 페이지 복사본에 대한 수정이 해당 프로세스에서만 보일 것인지, 아니면 다른 참조하는 프로세스와 공유할 것인지를 설정한다.</p>

<p><code class="language-plaintext highlighter-rouge">MAP_SHARED</code> : 이 플래그는 매핑을 다른 모든 프로세스들과 공유하기 위해 사용된다. 매핑된 영역에 대한 수정은 파일에 다시 쓰여진다.<br />
<code class="language-plaintext highlighter-rouge">MAP_PRIVATE</code> : 해당 플래그가 사용되면 매핑은 다른 프로세스들에게 보이지 않으며, 변경점들 또한 파일에 쓰여지지 않는다.<br />
<code class="language-plaintext highlighter-rouge">MAP_ANONYMOUS || MAP_ANON</code> : 익명의 매핑을 만들며, 파일 디스크립터로 인식하지 않는다. 어떠한 파일에도 연결되지 않으며, 힙을 늘리는 방식으로 사용된다.<br />
<code class="language-plaintext highlighter-rouge">MAP_FIXED</code> : 지정된 주소 이외의 다른 주소를 선택하지 않는다. 이 때, 지정된 주소가 사용될 수 없다면 mmap()은 실패한다.</p>

<h3 id="filedes">filedes</h3>

<p>매핑될 파일 디스크립터이다.</p>

<h3 id="offset-1">offset</h3>

<p>매핑할 때, 옮길 데이터의 시작점을 지정하는 인수이다.</p>

<h2 id="munmap">MUNMAP</h2>

<p><code class="language-plaintext highlighter-rouge">munmap()</code>함수는 가상메모리의 영역들을 삭제한다.</p>

<p>인수로는 <code class="language-plaintext highlighter-rouge">void *start</code>와 <code class="language-plaintext highlighter-rouge">size_t length</code>를 받으며,
이는 가상주소 <code class="language-plaintext highlighter-rouge">start</code>부터 <code class="language-plaintext highlighter-rouge">length</code>바이트로 이루어진 영역을 삭제하라는 말이다.<br />
<b>이후, 삭제된 영역으로의 참조는 세그먼트 오류를 발생시킨다.</b></p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer_Science" /></entry><entry><title type="html">가상화</title><link href="http://localhost:4000/computer/science/2024-02-03-first-post/" rel="alternate" type="text/html" title="가상화" /><published>2024-02-03T13:30:00+09:00</published><updated>2024-02-17T00:06:58+09:00</updated><id>http://localhost:4000/computer/science/first-post</id><content type="html" xml:base="http://localhost:4000/computer/science/2024-02-03-first-post/"><![CDATA[<p>가상화란 컴퓨터 리소스의 추상화를 의미한다.</p>

<p>추상화라는 단어가 CS에는 매우 자주 등장하는 듯 한데, 개인적으로 무언가를 추상화 하려면 이미지가 중요하다고 생각해서 이미지를 찾아보니 이런 걸 찾았다:</p>

<p><img />&lt;/img&gt;</p>

<p>가상화란,
하나의 물리 리소스를 여러개의 논리 리소스처럼 기능 시키거나,<br />
여러 개의 물리 리소스를 하나의 논리 리소스처럼 기능케 한다.</p>

<p>이게 무슨 말이냐면,<br />
하나의 실물 컴퓨팅 자원을 마치 여러 개인 것처럼 가상으로 쪼개서 사용하거나,<br />
여러 개의 실물 컴퓨팅 자원들을 묶어서 하나의 자원인 것처럼 사용하겠다는 것이다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="Computer" /><category term="Science" /><summary type="html"><![CDATA[가상화란 컴퓨터 리소스의 추상화를 의미한다.]]></summary></entry><entry><title type="html">힙 정렬</title><link href="http://localhost:4000/cs/algorithm/2024-01-15-heapsort/" rel="alternate" type="text/html" title="힙 정렬" /><published>2024-01-15T20:00:00+09:00</published><updated>2024-02-20T22:37:16+09:00</updated><id>http://localhost:4000/cs/algorithm/heapsort</id><content type="html" xml:base="http://localhost:4000/cs/algorithm/2024-01-15-heapsort/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#힙" id="markdown-toc-힙">힙</a></li>
  <li><a href="#힙-정렬" id="markdown-toc-힙-정렬">힙 정렬</a>    <ul>
      <li><a href="#시간-복잡도" id="markdown-toc-시간-복잡도">시간 복잡도</a></li>
    </ul>
  </li>
</ul>

<h2 id="힙">힙</h2>

<p>힙이란 완전 이진 트리의 일종이며, <br />
여러 개의 값들 중에서 최대값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.<br />
최대 힙 기준으로 큰 키값이 상위 레벨에 있고 작은 키값이 하위 레벨에 있으며<br />
이러한 특징으로 인해 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 이진 트리이다.</p>

<p>자세한 내용은 <a href="http://jaenam615.github.io/cs/datastructure/2024-01-12-heap/">힙</a>에 정리되어있다.</p>

<h2 id="힙-정렬">힙 정렬</h2>

<p>힙 자료구조를 사용하여 정렬하는 알고리즘이다.</p>

<p>힙 정렬은 배열로 표현된 트리의 값들을 이당(삭제 및 다시 삽입)시켜 다시 배열로 정렬하는 방식으로 구현하는데,<br />
힙 배열의 루트에서 원소를 삭제하여 줄어든 힙 배열 크기 뒤에 남는 공간에 삭제한 원소를 도로 넣음으로 정렬을 한다.<br />
<br />
<img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F2133cb71-0c2c-48db-a62c-da90ddfc6ff9%2FUntitled.png?table=block&amp;id=3de1282c-d289-4b0b-8620-eb0006f54d8c&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=2000&amp;userId=&amp;cache=v2" alt="initialheap" width="550" /></p>

<table>
  <tbody>
    <tr>
      <td>50</td>
      <td>30</td>
      <td>20</td>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td>16</td>
    </tr>
  </tbody>
</table>

<p>위는 값들이 들어간 힙과 그에 대응되는 배열을 시각적으로 표현한 것이다.</p>

<p>힙 정렬을 하려면 값들을 삭제해야 하는데, 힙에서의 삭제는 루트 노드에서만 이루어진다.<br />
주의해야 할 점은, <b>삭제되는 값 자체는 루트 노드의 값이지만, 삭제되는 노드는 단말 노드라는 점이다.</b><br />
삭제되는 노드는 단말 노드, 그 중 가장 오른쪽의 노드여야 하는데<br />
이는 힙이 항상 완전 이진 트리를 유지해야 하기 때문이다.</p>

<p>힙 정렬을 할 때 삭제되는 값은 루트 노드에 있는 값(가장 큰 값)이기 때문에<br />
루트 노드에 있는 값인 50을 먼저 삭제하고자 한다. 
다만 앞서 말했듯이 힙은 완전 이진 트리의 형태를 유지해야 함으로<br />
50의 위치를 최하위 레벨의 가장 우측 노드에 있는 값과 바꿔주고 50을 삭제한다.</p>

<!-- ![switched](https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F41546254-da8f-4882-a6e4-23bfc26797e5%2FUntitled.png?table=block&id=560182cf-659f-4e30-8bc3-ed56ab2d7179&spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&width=2000&userId=&cache=v2){: width="550" height="320";}

|  16  |  30  |  20  |  15  |  10  |   8  |  50  | -->
<p class="figcaption"><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F3b52846b-e4ae-48a5-bfa0-066290ee20dd%2FUntitled.png?table=block&amp;id=8578cff7-0a0a-4709-9288-72c02c4e6a81&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=930&amp;userId=&amp;cache=v2" alt="deleted" width="550" /><br />
50 삭제 후의 트리</p>

<!-- <style>
    .table1 td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>16</td>
      <td>30</td>
      <td>20</td>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>이 때, 비어있게 된 위치에 삭제된 값을 넣으면 추가적인 공간 할당 필요 없이<br />
가장 큰 값을 뒤 여유 공간에 위치하게 할 수 있다.<br />
회색으로 표시된 영역은 힙 배열의 크기가 줄어든 부분이며, 더 이상 힙 배열로서의 역할을 하지 않는다.</p>

<table>
  <tbody>
    <tr>
      <td>16</td>
      <td>30</td>
      <td>20</td>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<p>이제 50을 삭제하였으니 조정을 하여 다시 힙을 만들어야 한다.
16을 그 자식 노드들과 비교하여 큰 값과 바꿔주고 필요시 이를 반복하면 된다.</p>

<p><img src="https://janam.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd6bf389f-51e5-4356-b4a7-6b4bd35c1d89%2F45f0a677-9c9f-4d01-a9a4-a1dd6c48a9e4%2FUntitled.png?table=block&amp;id=8695fe0a-b01d-4088-8f95-3c4801e2c27c&amp;spaceId=d6bf389f-51e5-4356-b4a7-6b4bd35c1d89&amp;width=1160&amp;userId=&amp;cache=v2" alt="rebalancing" width="550" /></p>

<table>
  <tbody>
    <tr>
      <td>30</td>
      <td>16</td>
      <td>20</td>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<p>이제 30을 삭제하고, 30을 삭제한 후의 위의 과정을 진행한 힙 배열을 다시 정렬하면 아래의 힙 배열이 나온다.</p>

<!-- <style>
    td:nth-child(6) { background: lightgrey!important;}
    td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>20</td>
      <td>16</td>
      <td>8</td>
      <td>15</td>
      <td>10</td>
      <td>30</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<p>해당 과정을 반복해보자.</p>

<!-- <style>
    td:nth-child(5) { background: lightgrey!important;}
    td:nth-child(6) { background: lightgrey!important;}
    td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>16</td>
      <td>15</td>
      <td>8</td>
      <td>10</td>
      <td>20</td>
      <td>30</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<!-- <style>
    td:nth-child(4) { background: lightgrey!important;}
    td:nth-child(5) { background: lightgrey!important;}
    td:nth-child(6) { background: lightgrey!important;}
    td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>15</td>
      <td>10</td>
      <td>8</td>
      <td>16</td>
      <td>20</td>
      <td>30</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<!-- <style>
    td:nth-child(3) { background: lightgrey!important;}
    td:nth-child(4) { background: lightgrey!important;}
    td:nth-child(5) { background: lightgrey!important;}
    td:nth-child(6) { background: lightgrey!important;}
    td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>10</td>
      <td>8</td>
      <td>15</td>
      <td>16</td>
      <td>20</td>
      <td>30</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<!-- <style>
    td:nth-child(2) { background: lightgrey!important;}
    td:nth-child(3) { background: lightgrey!important;}
    td:nth-child(4) { background: lightgrey!important;}
    td:nth-child(5) { background: lightgrey!important;}
    td:nth-child(6) { background: lightgrey!important;}
    td:nth-child(7) { background: lightgrey!important;}
</style> -->

<table>
  <tbody>
    <tr>
      <td>8</td>
      <td>10</td>
      <td>15</td>
      <td>16</td>
      <td>20</td>
      <td>30</td>
      <td>50</td>
    </tr>
  </tbody>
</table>

<p>힙 정렬이 완료되어 가장 작은 값부터 큰 값까지 정렬된 것을 확인할 수 있다.
보이듯 힙 정렬은 힙 배열의 크기를 줄이면서 정렬을 하는 방식이다.</p>

<p>최소 힙이라 가정할 시 가장 작은 값을 삭제하는 방식으로 위 과정을 진행하면 정렬된 배열이 내림차순으로 정렬된다.</p>

<h3 id="시간-복잡도">시간 복잡도</h3>

<p>힙 정렬의 시간 복잡도는 O(nlogn)이다.<br />
힙을 만드는데 O(n)의 시간이 걸리고, 힙을 정렬하는데 O(nlogn)의 시간이 걸리기 때문이다.<br />
힙 정렬은 최악의 경우 O(nlogn)의 시간 복잡도를 보장하기 때문에 대규모 데이터를 정렬하는데에 효율적이다.<br />
다만, 상수 계수가 크기 때문에 데이터의 크기가 작을 경우에는 다른 정렬 알고리즘보다 느릴 수 있다는 단점도 있다.</p>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="algorithm" /><category term="알고리즘" /><category term="정렬" /></entry><entry><title type="html">배열과 연결 리스트</title><link href="http://localhost:4000/cs/datastructure/2024-01-11-array_linkedlist/" rel="alternate" type="text/html" title="배열과 연결 리스트" /><published>2024-01-11T15:00:00+09:00</published><updated>2024-02-20T17:03:37+09:00</updated><id>http://localhost:4000/cs/datastructure/array_linkedlist</id><content type="html" xml:base="http://localhost:4000/cs/datastructure/2024-01-11-array_linkedlist/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#배열" id="markdown-toc-배열">배열</a></li>
</ul>

<h2 id="배열">배열</h2>]]></content><author><name>Jaehee Nam</name><email>jaenam2060@gmail.com</email></author><category term="cs" /><category term="datastructure" /><category term="자료구조" /></entry></feed>