---
title: "데이터 모델과 질의 언어"
writer: James
date: 2025-07-20 00:00:02 +0900
categories: [devlog]
tags: [devlog, ddia]
pin: false
math: true
mermaid: true
image:
  path: https://dataintensive.net/images/book-cover.png
---

> 데이터 저장과 질의를 위한 다양한 **범용 데이터 모델**

---

## 🧱 관계형 모델 (Relational Model)

- 주로 **트랜잭션 처리**와 **일괄 처리**에 활용되는 전통적인 비즈니스 데이터 모델

> 💡 **관계형 DB vs NoSQL**
>
> - 대규모 데이터셋 처리와 높은 쓰기 처리량 요구 시 NoSQL이 적합  
> - 관계형 모델로는 어려운 특수 질의 처리 가능  
> - 더 유연하고 표현력이 뛰어난 데이터 모델링이 가능  
>
> 👉 결국, **요구사항에 따라 둘을 함께 사용하는 경우도 많다** → `Polyglot Persistence`

---

### 🔄 객체-관계형 불일치 (Object-Relational Impedance Mismatch)

- ORM (e.g. ActiveRecord, Hibernate)은 애플리케이션 객체 ↔ DB 모델 간 변환을 도와주지만, **모델 간 차이는 불가피**

> 💡 *예시: 관계형 DB에서 이력서(Resume)를 저장하는 방법*
>
> 1. **다중 테이블 구성**: 외래 키(FK) 기반 테이블 간 매핑 (직업, 학력, 연락처 등)
> 2. **JSON 타입 활용**: 일부 RDB는 JSON을 기본 지원
> 3. **문서 형태로 부호화**: JSON/XML 컬럼에 데이터 저장, 애플리케이션에서 파싱

---

> 📌 **JSON 모델의 장점**
>
> - 애플리케이션 코드와 저장 계층 간의 `impedance mismatch` 완화  
> - 다중 테이블 방식보다 **더 나은 데이터 지역성(locality)** 제공  

---

## 🧮 정규화 vs 비정규화

- 중복 최소화(정규화) vs 사용 편의성(비정규화)
- 예: **다대다 관계**에서 중복 값을 테이블로 분리 시 장점
  - 스타일 일관성
  - 모호성 제거
  - 데이터 갱신 용이성
  - 현지화/다국어 처리 지원
  - 검색 효율 향상

> 반면, 조인이 필요하며 애플리케이션 코드가 복잡해질 수 있음

- 중복 데이터를 직접 저장하면 조인은 필요 없지만, **데이터 중복 증가**
- 일부 DB는 조인을 지원하지 않기 때문에, **애플리케이션에서 직접 조인을 구현**해야 할 수도 있음
  - ➕ 성능 저하 가능성도 있음

---

## 🌳 계층 모델 (Hierarchical Model)

> 모든 데이터를 중첩된 레코드 트리 형태로 표현

> ⚠️ **계층 모델의 한계와 대안**
>
> 1. **관계형 모델**
>     - 관계 = 튜플(row)들의 컬렉션
>     - 복잡한 접근 경로 없이 `조건 기반 질의`로 read/write
>     - `Query Optimizer`가 접근 경로를 자동 생성
>
> 2. **네트워크 모델 (CODASYL)**
>     - 다대일 / 다대다 관계 모델링 가능
>     - 포인터처럼 root record부터 **연결 경로 따라 탐색**
>     - 새로운 index만 선언하면 DB가 최적 경로 자동 선택

---

## 🧾 질의 언어 (Query Language)

1. **선언형 질의 언어 (Declarative)**  
   - *“무엇을”* 해야 하는지를 기술
   - 병렬 실행 최적화에 유리  
   - DB 엔진 성능 향상이 가능 (질의 변경 없이)
   - 예: **SQL**, CSS, XSL

2. **명령형 API (Imperative)**  
   - *“어떻게”* 해야 하는지를 기술
   - 순서 기반 실행, 병렬 처리에 불리

---

### 🛠️ MapReduce 모델

- 대량 데이터를 분산 처리하기 위한 프로그래밍 모델  
- MongoDB의 `map`, `reduce` 함수의 제약:
  1. input 데이터만 사용 가능
  2. 추가 질의 수행 불가
  3. side effect 없어야 함

> 📌 MongoDB는 이를 보완하기 위해 **집계 파이프라인(Aggregation Pipeline)** 도입

---

## 📄 문서 모델 (Document Model)

- 하위 데이터를 **중첩된 구조**로 저장 (별도 테이블 아님)
- **문서 참조(Document Reference)** = RDB의 외래 키 역할
  - 조인 또는 후속 질의로 참조된 데이터 fetch

> 📌 장점
>
> - 유연한 스키마 구성  
> - 뛰어난 데이터 지역성  
> - `Schema-on-Read`: 데이터는 구조 없이 저장되고, **읽을 때 구조 해석**
>   - ➕ RDB는 `Schema-on-Write` 방식

> 💡 애플리케이션의 실제 데이터 구조와 유사 → 더 직관적

---

## 🕸️ 그래프 모델 (Graph Model)

> **정점(Node)** + **간선(Edge)** 기반 모델  
> 다양한 타입의 데이터를 하나의 그래프로 일관되게 저장 가능

![Graph Example](https://prod-files-secure.s3.us-west-2.amazonaws.com/56af06bd-af23-41ed-9eae-5faeee5a75ac/cd4d973a-029f-40bc-86b4-d068dc70333e/image.png)

- 예: 페이스북은 모든 데이터를 하나의 큰 그래프로 표현

---

### 그래프 모델의 주요 유형

1. **속성 그래프 모델**
   - 그래프용 선언형 질의 언어: `Cypher`
   - 유입/유출 간선 순회 가능
   - 스키마 강제 없음 → 유연한 모델링

2. **트리플 저장소 모델**
   - RDF 기반 (`Subject`, `Predicate`, `Object`)
   - 선언형 질의 언어: `SPARQL`
   - 웹 상의 **데이터 교환**을 위해 설계됨

3. **Datalog**
   - 논리 기반 질의 언어
   - 규칙과 서술어 기반 정의  
   
   ```prolog
   type(usa, country)
   within(usa, namerica)

   # 규칙 정의 예시
   db :- predicate
   within_recursive(Location, Name) :- within(Location, Via)
