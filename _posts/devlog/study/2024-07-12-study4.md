---
title: "네 번째 스터디"
writer: James
date: 2024-07-12 01:00:00 +0900
categories: [devlog, study]
tags: [devlog, study, 스터디]
pin: false
math: true
mermaid: true
image:
  path: https://github.com/jaenam615/jaenam615.github.io/assets/155196757/65e27245-2b82-4b56-94f6-22ab454f9984
---

## 네 번째 스터디  

저번 주의 스터디 분량과 내용이 꽤 맘에 들었다. 이렇게 면접 방식으로 내용을 안 보고 대답을 하니 내가 실제로 이해한 것과 단순히 옮겨 적은 게 무엇인지 구분이 되어 복습 측면에서도 도움이 되었다.  

이번 주는 지난 주에 이어서 운영체제 부분을 더 다루기로 했다. 이제 스터디에 차차 익숙해지고 있어서 주제 및 질문들, 그리고 풀 문제들만 지정하여 각자 열심히 하면 되는 단계인 것 같다. 문제의 난이도는 지난 주에 비해 꽤 많이 올라서 시간을 예상보다 많이 잡아먹었다...   

![image](https://github.com/jaenam615/jaenam615.github.io/assets/155196757/b31ea6ae-aa7a-4a61-a2ee-de7fd23584c6)   

### 키워드

#### 스케줄링 알고리즘  

**Q: 스케줄링 알고리즘에는 어떤 것들이 있나요?**  
A:  

가장 간단하게 구현할 수 있는 프로세스 스케줄링 알고리즘은 FCFS(First Come First Serve) 스케줄링으로, 단순히 준비 큐에 도착한 순서에 따라 자원을 할당받는 방법이다. 먼저 디스패치된 프로세스가 CPU를 차지하면 해당 프로세스의 수행이 완료된 후에 다음 프로세스가 CPU를 차지하고 수행하면 된다.  

이 밖의 스케줄링 알고리즘으로는 가장 짧은 실행 시간을 가질 것으로 예상되는 프로세스부터 처리하는 SJF(Shortest Job First) 스케줄링, 남은 실행시간이 가장 짧다고 예상되는 프로세스를 먼저 디스패치하는 SRT(Shortest Remaining Time) 스케줄링, 정해진 시간 할당량에 의해 실행을 제한하는 선점 방식의 RR(Round Robin) 스케줄링, 우선순위를 프로세스에 부여하여 우선도에 따라 처리하는 우선순위 스케줄링 등등이 있다.  

**Q: RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.**  
A:

#### 뮤텍스와 세마포어  

[뮤텍스와 세마포어 포스트]()

#### Deadlock  

[Deadlock 포스트](https://jaenam615.github.io/posts/deadlock/)  

**Q: 데드락이 발동하는 4가지 조건에 대해 설명해주세요.**  
A:  

데드락이란 두 개 이상의 프로세스가 서로의 자원을 기다리면서 무한하게 대기하는 상황을 말한다.  
데드락이 발동하기 위한 필요조건으로는 다음 네가지가 있다:  

1. 상호배제  
   - 자원은 한 번의 하나의 프로세스만 사용할 수 있음  
   - 다른 프로세스가 점유하고 있는 자원이 필요한 경우에 반드시 대기  
   - 자원의 일관성을 유지해야 하는 경우에 상호배제는 필요하지만, 데드락을 유발할 수 있음  
   - 예: 프로세스 A가 프린터를 사용 중인 경우, 프로세스 B는 프린터를 사용할 수 없으며 대기해야 함     
2. 점유대기  
   - 프로세스가 최소 하나의 자원을 점유하고 있으며, 다른 자원을 추가로 요청하여 대기 중  
   - 지원을 점유한 프로세스가 다른 자원을 기다리면서 데드락 발생 가능  
   - 예: 프로세스 A가 자원1을 점유한 상태에서 자원 2를 요청하고, 프로세스 B는 자원2를 점유한 상태에서 자원1을 요청  
3. 비선점  
   - 프로세스가 강제로 자원을 빼앗기지 않으며, 자원을 점유한 프로세스가 스스로 해제해야 함  
   - 자원을 요청한 프로세스는 이미 점유된 다른 자원을 강제로 빼앗을 수 없음  
4. 환형대기(순환대기)  
   - 자원들 사이에 프로세스들이 순환 형태로 대기   
   - 자원을 점유하고 있는 프로세스들이 서로의 자원을 기다리면서 무한하게 대기할 수 있음  

**Q: 이 중 하나가 빠진다고 가정하면 왜 Deadlock이 발생하지 않을까요?**  
A:  

1. 상호 배제 조건이 빠진 경우: 
   - 여러 프로세스가 동시에 같은 자원을 사용할 수 있기 때문에 자원을 두고 경쟁할 필요 자체가 없어지며, 자원 대기 샅애가 생기지 않는다.  
2. 점유 대기 조건이 빠진 경우:  
   - 프로세스가 자원을 점유하며 대기하는 것이 방지되면 필요한 모든 자원을 처음부터 할당받거나, 자원을 해제하고 다시 요청해야 한다. 즉, 자원을 붙잡고 기다리는 상황이 없어진다.  
3. 비선점 조건이 빠진 경우:  
   - 자원을 점유하고 있는 프로세스가 다른 프로세스에 의해 강제로 자원을 빼앗길 수 있다면 특정 프로세스가 점유한 필요 자원을 가져올 수 있기 때문에 대기 상태에 빠지지 않는다.  
4. 순환 대기 조건이 빠진 경우:  
   - 위상 정렬과 같이 자원 요청이 선형적으로 이루어지게 되는데, 이러면 순차적으로 모든 자원이 해제가 되며 데드락이 발생하지 않는다.  

**Q: Deadlock 예방은 어떻게 하나요?**  
A:  

데드락의 발생 조건 네가지 중 하나라도 발생하지 않도록 설계하고 관리하면 데드락을 예방할 수 있다.  

1. 상호 배제 방지:  
   - 가능한 경우 자원을 공유 가능하도록 설계한다.  
   - 단, 읽기 전용 데이터 같은 경우에는 위의 설계가 가능하지만, 프린터와 같은 자원의 경우 상호 배제를 피할 수 없기 떄문에 다른 조건을 통해 예방해야 한다.  
2. 점유 대기 방지: 
   - 프로세스가 자원을 요청할 때 다른 자원을 점유하지 않은 상태에서만 요청하도록 설계한다.  
   - 자원을 모두 해제한 후 다시 요청하는 방식으로 구현 가능하다.  
   - 프로세스가 시작하기 전에 필요한 모든 자원을 한꺼번에 요청하고 할당받도록 설계한다.  
   - 필요한 모든 자원을 할당받지 못하는 경우 실행하지 않는다.  
3. 비선점 방지:  
   - 이미 할당된 자원을 강제로 회수할 수 있는 방식을 도입한다.  
   - CPU 스케줄링에서 선점형 스케줄링 기법을 사용하면 된다.  
4. 순환 대기 방지:  
   - 자원 할당 순서 규칙을 만들어 자원에 고유한 순서를 부여하고, 프로세스가 자원을 요청할 때 해당 순서대로 요청하게 한다.  
   - 자원 A와 B가 있을 때 프로세스는 A를 요청한 후 B를 요청해야 하며, 반대로 요청할 수 없다.  

**Q: Wait Free와 Lock Free를 비교해 주세요.**  
A:  




#### 프로그램 컴파일  

### 문제 풀이  

[**줄 세우기**](https://www.acmicpc.net/problem/2631)
```python
import sys 
input = sys.stdin.readline

N = int(input())
kids = []
dp = []

for _ in range(N):
    kids.append(int(input()))

def lis(arr):
    n = len(arr)
    dp = [1] * n 

    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j]+1)
    
    return max(dp)

print(N - lis(kids))
```

[**완전 이진 트리**](https://www.acmicpc.net/problem/9934)
```python
import sys
input = sys.stdin.readline

K = int(input())
inorder = list(map(int, input().split()))

# 레벨에 해당하는 배열 생성
levels = [[] for _ in range(K)]
 
def make_level(arr, current_level, levels):
    if not arr:
        return

    mid = len(arr)//2 

    levels[current_level].append(arr[mid])

    make_level(arr[:mid], current_level + 1, levels)
    make_level(arr[mid+1:], current_level + 1, levels)

make_level(inorder, 0, levels)

for level in levels:
    print(*level, sep= " ")
```