---
title: "메모리 단편화 Memory Fragmentation"
writer: Langerak
date: 2024-02-18 12:00:00 +0800
categories: [Computer Science, Operating System]
tags: [Computer Science, Operating System]
pin: false
math: true
mermaid: true
image:
  path: https://github.com/JeongJongMun/JeongJongMun.github.io/assets/101979073/4c602e4a-c5ea-4a74-8b79-ba305c64299e
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt: Operating System
---

> 본 글은 제 개인적인 공부를 위해 작성한 글입니다. 틀린 내용이 있다면 언제든지 피드백을 주시면 감사하겠습니다. 참고로만 활용해주시길 바랍니다.



## 메모리 단편화

---

RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 **사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태**를 보고 `메모리 단편화`가 발생했다고 한다. 

메모리 단편화 현상은 기억장치의 사용 가능한 공간을 줄이거나, 읽기/쓰기의 속도를 늦추는 문제점을 야기한다.

## 메모리 단편화의 종류

---

### 내부 단편화 Internal Fragmentation

기억 장치가 의도된 바 없이 할당되어 공간이 낭비되는 현상을 말한다.

`내부`라는 용어는 필요 없는 기억 자료가, 할당된 영역 안에 있지만 쓰이지 않는 것을 말한다.

메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황이다.

메모리 관리 기법 중 페이징 기법을 사용할 때 발생할 수 있다.

가령 메모장을 켰는데 운영체제가 $4kb$를 할당해줬다. 그런데 사실상 $1kb$만큼 사용하고 있을 때, 필요 이상으로 프로세스가 메모리를 할당받았으므로 내부 단편화가 $3kb$만큼 생긴 것이다.

### 외부 단편화 External Fragmentation

메모리의 여유 공간이 여러 조각으로 나뉘는 현상을 말한다.

`외부`라는 용어는 사용할 수 없는 기억 장소가 할당된 영역 밖에 있다는 것을 뜻한다.

메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간 중간 존재하게 된다. 이 때 중간 중간에 생긴 **사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황**이다.

가령 메모리의 처음 주소에 $8mb$짜리 프로세스 $A$를 할당하고, 바로 이어서 $16mb$ 짜리 프로세스 $B$를 할당했다. 그리고 $A$를 종료시키면 메모리의 처음 주소에 $8mb$만큼의 공간이 생긴다.

이런 식으로 반복하면 빈 메모리가 쌓이게 되고, 나중에 $9mb$짜리 프로세스 $C$를 할당하려 할 때, 마땅한 공간은 없지만 전체적으로 메모리 여유는 있을 때 외부 단편화가 생겼다고 한다.

## 메모리 단편화 해결 방법

---

### 통합 Coalescing

메모리 내에 인접한 둘 이상의 공백을 그들 사이의 경계를 없애고 하나의 공백으로 합치는 것이다.

### 집약(압축) Compaction

메모리 내에 섞여있는 사용 중인 영역과 빈 영역을 각각 한쪽으로 몰아 빈 영역들을 하나로 모으는 것이다.

디스크 조각 모음이 하드디스크 상에서 집약을 수행하는 프로그램의 대표적인 예이다.

### 페이징 Paging

> 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재

연속적이지 않은 공간도 활용할 수 있기 때문에 **외부 단편화 문제를 해결**할 수 있다.

페이지 단위를 가득 채워 사용하는 것이 아니므로 **내부 단편화 문제는 존재**한다.

페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만, `페이지 매핑 과정`이 많아져 오히려 **비효율적**일 수 있다.

### 세그멘테이션 Segmentation

> 가상 메모리 사용, 외부 단편화 존재, 내부 단편화 해결

프로세스가 필요한 메모리만큼 할당해주기 때문에 **내부 단편화를 해결**할 수 있다.

프로세스가 메모리를 해제하면 여전히 **외부 단편화 문제**는 존재한다.

### 메모리 풀

> 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법
> 

큰 메모리 공간을 할당 받고, 필요할 때마다 가져다 쓰고 반납하기에 **외부 단편화를 해결**할 수 있다.

또한 필요한 크기만큼 할당하기 때문에 **내부 단편화도 해결**할 수 있다.

하지만,

1. `너무 작은 메모리 풀`을 사용하는 경우 메모리가 부족하여 충돌 가능하다.
2. `너무 큰 메모리 풀`을 사용하는 경우 메모리 낭비 가능하다.
3. 운영 체제의 메모리 관리에 의존하지 않고 **프로그램이 자체적으로 메모리를 관리**하기 때문에 메모리 관련 문제를 `디버깅`하기 어려움
4. 메모리 풀을 할당해놓으면 사용하지 않는 순간에도 계속 할당해놓으므로 `메모리 누수`가 있는 방식이다.
<br/> <br/>

*참고*
- [https://ko.wikipedia.org/wiki/단편화](https://ko.wikipedia.org/wiki/단편화)
- [https://jeong-pro.tistory.com/91](https://jeong-pro.tistory.com/91)
- [https://ko.wikipedia.org/wiki/통합과_집약](https://ko.wikipedia.org/wiki/통합과_집약)